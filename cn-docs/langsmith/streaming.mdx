---
title: 流式 API
sidebarTitle: Streaming API
---
[LangGraph SDK](/langsmith/langgraph-python-sdk) 允许你从 [LangSmith 部署 API](/langsmith/server-api-ref) [流式传输输出](/oss/langgraph/streaming/)。

<Note>
LangGraph SDK 和 Agent Server 是 [LangSmith](/langsmith/home) 的一部分。
</Note>

## 基本用法

基本用法示例：

<Tabs>
    <Tab title="Python">
    ```python {highlight={12}}
    from langgraph_sdk import get_client
    client = get_client(url=<DEPLOYMENT_URL>, api_key=<API_KEY>)

    # 使用部署名称为 "agent" 的图
    assistant_id = "agent"

    # 创建一个线程
    thread = await client.threads.create()
    thread_id = thread["thread_id"]

    # 创建一个流式运行
    async for chunk in client.runs.stream(
        thread_id,
        assistant_id,
        input=inputs,
        stream_mode="updates"
    ):
        print(chunk.data)
```
    </Tab>
    <Tab title="JavaScript">
    ```javascript {highlight={12}}
    import { Client } from "@langchain/langgraph-sdk";
    const client = new Client({ apiUrl: <DEPLOYMENT_URL>, apiKey: <API_KEY> });

    // 使用部署名称为 "agent" 的图
    const assistantID = "agent";

    // 创建一个线程
    const thread = await client.threads.create();
    const threadID = thread["thread_id"];

    // 创建一个流式运行
    const streamResponse = client.runs.stream(
      threadID,
      assistantID,
      {
        input,
        streamMode: "updates"
      }
    );
    for await (const chunk of streamResponse) {
      console.log(chunk.data);
    }
```
    </Tab>
    <Tab title="cURL">
    创建一个线程：

    ```bash
    curl --request POST \
    --url <DEPLOYMENT_URL>/threads \
    --header 'Content-Type: application/json' \
    --data '{}'
    ```

    创建一个流式运行：

    ```bash
    curl --request POST \
    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \
    --header 'Content-Type: application/json' \
    --header 'x-api-key: <API_KEY>'
    --data "{
      \"assistant_id\": \"agent\",
      \"input\": <inputs>,
      \"stream_mode\": \"updates\"
    }"
    ```
    </Tab>
</Tabs>

<Accordion title="扩展示例：流式传输更新">
  这是一个你可以在 Agent Server 中运行的示例图。
  更多详情请参阅 [LangSmith 快速入门](/langsmith/deployment-quickstart)。

  ```python
  # graph.py
  from typing import TypedDict
  from langgraph.graph import StateGraph, START, END

  class State(TypedDict):
      topic: str
      joke: str

  def refine_topic(state: State):
      return {"topic": state["topic"] + " and cats"}

  def generate_joke(state: State):
      return {"joke": f"This is a joke about {state['topic']}"}

  graph = (
      StateGraph(State)
      .add_node(refine_topic)
      .add_node(generate_joke)
      .add_edge(START, "refine_topic")
      .add_edge("refine_topic", "generate_joke")
      .add_edge("generate_joke", END)
      .compile()
  )
  ```

  一旦你有一个运行中的 Agent Server，你就可以使用
  [LangGraph SDK](/langsmith/langgraph-python-sdk) 与其交互。

    <Tabs>
        <Tab title="Python">
      ```python {highlight={12,16}}
      from langgraph_sdk import get_client
      client = get_client(url=<DEPLOYMENT_URL>)

      # 使用部署名称为 "agent" 的图
      assistant_id = "agent"

      # 创建一个线程
      thread = await client.threads.create()
      thread_id = thread["thread_id"]

      # 创建一个流式运行
      async for chunk in client.runs.stream(  # (1)!
          thread_id,
          assistant_id,
          input={"topic": "ice cream"},
          stream_mode="updates"  # (2)!
      ):
          print(chunk.data)
```

      1. `client.runs.stream()` 方法返回一个迭代器，产生流式输出。
      2. 设置 `stream_mode="updates"` 以仅流式传输每个节点后图状态的更新。其他流模式也可用。详情请参阅 [支持的流模式](#supported-stream-modes)。
        </Tab>
        <Tab title="JavaScript">
      ```javascript {highlight={12,17}}
      import { Client } from "@langchain/langgraph-sdk";
      const client = new Client({ apiUrl: <DEPLOYMENT_URL> });

      // 使用部署名称为 "agent" 的图
      const assistantID = "agent";

      // 创建一个线程
      const thread = await client.threads.create();
      const threadID = thread["thread_id"];

      // 创建一个流式运行
      const streamResponse = client.runs.stream(  // (1)!
        threadID,
        assistantID,
        {
          input: { topic: "ice cream" },
          streamMode: "updates"  // (2)!
        }
      );
      for await (const chunk of streamResponse) {
        console.log(chunk.data);
      }
```

      1. `client.runs.stream()` 方法返回一个迭代器，产生流式输出。
      2. 设置 `streamMode: "updates"` 以仅流式传输每个节点后图状态的更新。其他流模式也可用。详情请参阅 [支持的流模式](#supported-stream-modes)。
        </Tab>
        <Tab title="cURL">
      创建一个线程：

      ```bash
      curl --request POST \
      --url <DEPLOYMENT_URL>/threads \
      --header 'Content-Type: application/json' \
      --data '{}'
      ```

      创建一个流式运行：

      ```bash
      curl --request POST \
      --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \
      --header 'Content-Type: application/json' \
      --data "{
        \"assistant_id\": \"agent\",
        \"input\": {\"topic\": \"ice cream\"},
        \"stream_mode\": \"updates\"
      }"
      ```
        </Tab>
    </Tabs>

  ```python
  {'run_id': '1f02c2b3-3cef-68de-b720-eec2a4a8e920', 'attempt': 1}
  {'refine_topic': {'topic': 'ice cream and cats'}}
  {'generate_joke': {'joke': 'This is a joke about ice cream and cats'}}
  ```
</Accordion>

### 支持的流模式

| 模式                             | 描述                                                                                                                                                                         | LangGraph 库方法                                                                                 |
|----------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|
| [`values`](#stream-graph-state)  | 在每个 [超级步骤 (super-step)](/langsmith/graph-rebuild#graphs) 后流式传输完整的图状态。                                                                                            | `.stream()` / `.astream()` 配合 [`stream_mode="values"`](/oss/langgraph/streaming#stream-graph-state)  |
| [`updates`](#stream-graph-state) | 在图执行的每个步骤后流式传输状态的更新。如果同一步骤中有多个更新（例如，运行了多个节点），这些更新会分别流式传输。 | `.stream()` / `.astream()` 配合 [`stream_mode="updates"`](/oss/langgraph/streaming#stream-graph-state) |
| [`messages-tuple`](#messages)    | 从调用 LLM 的图节点流式传输 LLM 令牌和元数据（对聊天应用很有用）。                                                                                 | `.stream()` / `.astream()` 配合 [`stream_mode="messages"`](/oss/langgraph/streaming#messages)          |
| [`debug`](#debug)                | 在图执行过程中流式传输尽可能多的信息。                                                                                                      | `.stream()` / `.astream()` 配合 [`stream_mode="debug"`](/oss/langgraph/streaming#stream-graph-state)   |
| [`custom`](#stream-custom-data)  | 从图内部流式传输自定义数据                                                                                                                                          | `.stream()` / `.astream()` 配合 [`stream_mode="custom"`](/oss/langgraph/streaming#stream-custom-data)  |
| [`events`](#stream-events)       | 流式传输所有事件（包括图的状态）；主要在迁移大型 LCEL 应用时有用。                                                                                 | `.astream_events()`                                                                                      |

### 流式传输多种模式

你可以传递一个列表作为 `stream_mode` 参数，以同时流式传输多种模式。

流式输出将是 `(mode, chunk)` 的元组，其中 `mode` 是流模式的名称，`chunk` 是该模式流式传输的数据。

<Tabs>
    <Tab title="Python">
    ```python
    async for chunk in client.runs.stream(
        thread_id,
        assistant_id,
        input=inputs,
        stream_mode=["updates", "custom"]
    ):
        print(chunk)
    ```
    </Tab>
    <Tab title="JavaScript">
    ```js
    const streamResponse = client.runs.stream(
      threadID,
      assistantID,
      {
        input,
        streamMode: ["updates", "custom"]
      }
    );
    for await (const chunk of streamResponse) {
      console.log(chunk);
    }
    ```
    </Tab>
    <Tab title="cURL">
    ```bash
    curl --request POST \
     --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \
     --header 'Content-Type: application/json' \
     --data "{
       \"assistant_id\": \"agent\",
       \"input\": <inputs>,
       \"stream_mode\": [
         \"updates\"
         \"custom\"
       ]
     }"
    ```
    </Tab>
</Tabs>

## 流式传输图状态

使用流模式 `updates` 和 `values` 在图执行时流式传输其状态。

* `updates` 流式传输图每个步骤后状态的**更新**。
* `values` 流式传输图每个步骤后状态的**完整值**。

<Accordion title="示例图">
  ```python
  from typing import TypedDict
  from langgraph.graph import StateGraph, START, END

  class State(TypedDict):
    topic: str
    joke: str

  def refine_topic(state: State):
      return {"topic": state["topic"] + " and cats"}

  def generate_joke(state: State):
      return {"joke": f"This is a joke about {state['topic']}"}

  graph = (
    StateGraph(State)
    .add_node(refine_topic)
    .add_node(generate_joke)
    .add_edge(START, "refine_topic")
    .add_edge("refine_topic", "generate_joke")
    .add_edge("generate_joke", END)
    .compile()
  )
  ```
</Accordion>

<Note>
**有状态的运行**
以下示例假设你希望将流式运行的输出**持久化**到 [检查点 (checkpointer)](/oss/langgraph/persistence) 数据库，并且已经创建了一个线程。要创建一个线程：

<Tabs>
<Tab title="Python">
```python
from langgraph_sdk import get_client
client = get_client(url=<DEPLOYMENT_URL>)

# 使用部署名称为 "agent" 的图
assistant_id = "agent"
# 创建一个线程
thread = await client.threads.create()
thread_id = thread["thread_id"]
```
</Tab>
<Tab title="JavaScript">
```js
import { Client } from "@langchain/langgraph-sdk";
const client = new Client({ apiUrl: <DEPLOYMENT_URL> });

// 使用部署名称为 "agent" 的图
const assistantID = "agent";
// 创建一个线程
const thread = await client.threads.create();
const threadID = thread["thread_id"]
```
</Tab>
<Tab title="cURL">
```bash
curl --request POST \
--url <DEPLOYMENT_URL>/threads \
--header 'Content-Type: application/json' \
--data '{}'
```
</Tab>
</Tabs>

如果你不需要持久化运行的输出，可以在流式传输时传递 `None` 而不是 `thread_id`。
</Note>

### 流模式：`updates`

使用此模式仅流式传输每个步骤后节点返回的**状态更新**。流式输出包括节点名称和更新内容。

<Tabs>
    <Tab title="Python">
    ```python {highlight={5}}
    async for chunk in client.runs.stream(
        thread_id,
        assistant_id,
        input={"topic": "ice cream"},
        stream_mode="updates"
    ):
        print(chunk.data)
```
    </Tab>
    <Tab title="JavaScript">
    ```javascript {highlight={6}}
    const streamResponse = client.runs.stream(
      threadID,
      assistantID,
      {
        input: { topic: "ice cream" },
        streamMode: "updates"
      }
    );
    for await (const chunk of streamResponse) {
      console.log(chunk.data);
    }
```
    </Tab>
    <Tab title="cURL">
    ```bash
    curl --request POST \
    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \
    --header 'Content-Type: application/json' \
    --data "{
      \"assistant_id\": \"agent\",
      \"input\": {\"topic\": \"ice cream\"},
      \"stream_mode\": \"updates\"
    }"
    ```
    </Tab>
</Tabs>

### 流模式：`values`

使用此模式流式传输每个步骤后图的**完整状态**。

<Tabs>
    <Tab title="Python">
    ```python {highlight={5}}
    async for chunk in client.runs.stream(
        thread_id,
        assistant_id,
        input={"topic": "ice cream"},
        stream_mode="values"
    ):
        print(chunk.data)
```
    </Tab>
    <Tab title="JavaScript">
    ```javascript {highlight={6}}
    const streamResponse = client.runs.stream(
      threadID,
      assistantID,
      {
        input: { topic: "ice cream" },
        streamMode: "values"
      }
    );
    for await (const chunk of streamResponse) {
      console.log(chunk.data);
    }
```
    </Tab>
    <Tab title="cURL">
    ```bash
    curl --request POST \
    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \
    --header 'Content-Type: application/json' \
    --data "{
      \"assistant_id\": \"agent\",
      \"input\": {\"topic\": \"ice cream\"},
      \"stream_mode\": \"values\"
    }"
    ```
    </Tab>
</Tabs>

## 子图

要将[子图](/oss/langgraph/use-subgraphs)的输出包含在流式输出中，你可以在父图的 `.stream()` 方法中设置 `subgraphs=True`。这将同时流式传输父图和任何子图的输出。

```python {highlight={5}}
async for chunk in client.runs.stream(
    thread_id,
    assistant_id,
    input={"foo": "foo"},
    stream_subgraphs=True, # (1)!
    stream_mode="updates",
):
    print(chunk)
```

1. 设置 `stream_subgraphs=True` 以流式传输子图的输出。

<Accordion title="扩展示例：从子图流式传输">
  这是一个你可以在 Agent Server 中运行的示例图。
  更多详情请参阅 [LangSmith 快速入门](/langsmith/deployment-quickstart)。

  ```python
  # graph.py
  from langgraph.graph import START, StateGraph
  from typing import TypedDict

  # 定义子图
  class SubgraphState(TypedDict):
      foo: str  # 注意这个键与父图状态共享
      bar: str

  def subgraph_node_1(state: SubgraphState):
      return {"bar": "bar"}

  def subgraph_node_2(state: SubgraphState):
      return {"foo": state["foo"] + state["bar"]}

  subgraph_builder = StateGraph(SubgraphState)
  subgraph_builder.add_node(subgraph_node_1)
  subgraph_builder.add_node(subgraph_node_2)
  subgraph_builder.add_edge(START, "subgraph_node_1")
  subgraph_builder.add_edge("subgraph_node_1", "subgraph_node_2")
  subgraph = subgraph_builder.compile()

  # 定义父图
  class ParentState(TypedDict):
      foo: str

  def node_1(state: ParentState):
      return {"foo": "hi! " + state["foo"]}

  builder = StateGraph(ParentState)
  builder.add_node("node_1", node_1)
  builder.add_node("node_2", subgraph)
  builder.add_edge(START, "node_1")
  builder.add_edge("node_1", "node_2")
  graph = builder.compile()
  ```

  一旦你有一个运行中的 Agent Server，你就可以使用
  [LangGraph SDK](/langsmith/langgraph-python-sdk) 与其交互。

    <Tabs>
        <Tab title="Python">
      ```python {highlight={15}}
      from langgraph_sdk import get_client
      client = get_client(url=<DEPLOYMENT_URL>)

      # 使用部署名称为 "agent" 的图
      assistant_id = "agent"

      # 创建一个线程
      thread = await client.threads.create()
      thread_id = thread["thread_id"]

      async for chunk in client.runs.stream(
          thread_id,
          assistant_id,
          input={"foo": "foo"},
          stream_subgraphs=True, # (1)!
          stream_mode="updates",
      ):
          print(chunk)
```

      1. 设置 `stream_subgraphs=True` 以流式传输子图的输出。
        </Tab>
        <Tab title="JavaScript">
      ```javascript {highlight={17}}
      import { Client } from "@langchain/langgraph-sdk";
      const client = new Client({ apiUrl: <DEPLOYMENT_URL> });

      // 使用部署名称为 "agent" 的图
      const assistantID = "agent
