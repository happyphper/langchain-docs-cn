---
title: 使用 Pytest/Vitest 和 LangSmith 测试 ReAct 智能体
sidebarTitle: Test a ReAct agent with Pytest/Vitest and LangSmith
---
本教程将展示如何使用 LangSmith 与流行的测试工具（Pytest、Vitest 和 Jest）的集成来评估您的 LLM 应用程序。我们将创建一个 ReAct 智能体，用于回答关于公开交易股票的问题，并为其编写一个全面的测试套件。

## 设置

本教程使用 [LangGraph](https://langchain-ai.github.io/langgraph/tutorials/introduction/) 进行智能体编排，使用 [OpenAI 的 GPT-4o](https://platform.openai.com/docs/models#gpt-4o) 作为模型，[Tavily](https://tavily.com/) 进行搜索，[E2B](https://e2b.dev/) 的代码解释器，以及 [Polygon](https://polygon.io/stocks) 来获取股票数据，但只需稍作修改即可适配其他框架、模型和工具。Tavily、E2B 和 Polygon 均可免费注册。

### 安装

首先，安装构建智能体所需的包：

<CodeGroup>

```bash Python
pip install -U langgraph langchain[openai] langchain-community e2b-code-interpreter
```

```bash TypeScript
yarn add @langchain/openai @langchain/community @langchain/langgraph @langchain/core @e2b/code-interpreter @polygon.io/client-js openai zod
```

</CodeGroup>

接下来，安装测试框架：

<CodeGroup>

```bash Pytest
# 确保您有 langsmith>=0.3.1
pip install -U "langsmith[pytest]"
```

```bash Vitest
yarn add -D langsmith vitest
```

```bash Jest
yarn add -D langsmith jest
```

</CodeGroup>

### 环境变量

设置以下环境变量：

```bash
export LANGSMITH_TRACING=true
export LANGSMITH_API_KEY=<YOUR_LANGSMITH_API_KEY>
export OPENAI_API_KEY=<YOUR_OPENAI_API_KEY>
export TAVILY_API_KEY=<YOUR_TAVILY_API_KEY>
export E2B_API_KEY=<YOUR_E2B_API_KEY>
export POLYGON_API_KEY=<YOUR_POLYGON_API_KEY>
```

## 创建您的应用

为了定义我们的 ReAct 智能体，我们将使用 LangGraph/LangGraph.js 进行编排，并使用 LangChain 处理 LLM 和工具。

### 定义工具

首先，我们将定义智能体将要使用的工具。总共会有 3 个工具：

* 使用 Tavily 的搜索工具
* 使用 E2B 的代码解释器工具
* 使用 Polygon 的股票信息工具

<CodeGroup>

```python Python
from langchain_community.tools import TavilySearchResults
from e2b_code_interpreter import Sandbox
from langchain_community.tools.polygon.aggregates import PolygonAggregates
from langchain_community.utilities.polygon import PolygonAPIWrapper
from typing_extensions import Annotated, TypedDict, Optional, Literal

# 定义搜索工具
search_tool = TavilySearchResults(
  max_results=5,
  include_raw_content=True,
)

# 定义代码工具
def code_tool(code: str) -> str:
  """执行 python 代码并返回结果。"""
  sbx = Sandbox()
  execution = sbx.run_code(code)

  if execution.error:
      return f"Error: {execution.error}"
  return f"Results: {execution.results}, Logs: {execution.logs}"

# 定义股票代码工具的输入模式
class TickerToolInput(TypedDict):
  """股票代码工具的输入格式。
    该工具将以聚合块（timespan_multiplier * timespan）的形式从 from_date 到 to_date 拉取数据
  """
  ticker: Annotated[str, ..., "股票的代码符号"]
  timespan: Annotated[Literal["minute", "hour", "day", "week", "month", "quarter", "year"], ..., "时间窗口的大小。"]
  timespan_multiplier: Annotated[int, ..., "时间窗口的乘数"]
  from_date: Annotated[str, ..., "开始拉取数据的日期，YYYY-MM-DD 格式 - 仅包含年月日"]
  to_date: Annotated[str, ..., "停止拉取数据的日期，YYYY-MM-DD 格式 - 仅包含年月日"]

api_wrapper = PolygonAPIWrapper()
polygon_aggregate = PolygonAggregates(api_wrapper=api_wrapper)

# 定义股票代码工具
def ticker_tool(query: TickerToolInput) -> str:
  """拉取股票代码的数据。"""
  return polygon_aggregate.invoke(query)
```

```typescript TypeScript
import { TavilySearchResults } from "@langchain/community/tools/tavily_search";
import { Sandbox } from "@e2b/code-interpreter";
import { tool } from "@langchain/core/tools";
import { z } from "zod";
import { restClient } from "@polygon.io/client-js";

// 定义搜索工具
const searchTool = new TavilySearchResults({
  maxResults: 5,
});

// 定义代码工具
const codeTool = tool(async (input) => {
  const sbx = await Sandbox.create();
  const execution = await sbx.runCode(input.code);
  if (execution.error) {
    return `Error: ${execution.error}`;
  }
  return `Results: ${execution.results}, Logs: ${execution.logs}`;
}, {
  name: "code",
  description: "Execute python code and return the result.",
  schema: z.object({
    code: z.string().describe("The python code to execute"),
  }),
});

// 定义股票代码工具的输入模式
const TickerToolInputSchema = z.object({
  ticker: z.string().describe("The ticker symbol of the stock"),
  timespan: z.enum(["minute", "hour", "day", "week", "month", "quarter", "year"]).describe("The size of the time window."),
  timespan_multiplier: z.number().describe("The multiplier for the time window"),
  from_date: z
    .string()
    .describe("The date to start pulling data from, YYYY-MM-DD format - ONLY include the year, month, and day"),
  to_date: z
    .string()
    .describe("The date to stop pulling data, YYYY-MM-DD format - ONLY include the year, month, and day"),
});

const rest = restClient(process.env.POLYGON_API_KEY);

// 定义股票代码工具
const tickerTool = tool(async (query) => {
  const parsed = TickerToolInputSchema.parse(query);
  const result = await rest.stocks.aggregates(
      parsed.ticker,
      parsed.timespan_multiplier,
      parsed.timespan,
      parsed.from_date,
      parsed.to_date
  );
  return JSON.stringify(result);
}, {
  name: "ticker",
  description: "Pull data for the ticker",
  schema: TickerToolInputSchema,
});
```

</CodeGroup>

### 定义智能体

现在我们已经定义了所有工具，我们可以使用 @[`create_agent`] 来创建我们的智能体。

<CodeGroup>

```python Python
from typing_extensions import Annotated, TypedDict
from langchain.agents import create_agent


class AgentOutputFormat(TypedDict):
    numeric_answer: Annotated[float | None, ..., "数字答案，如果用户要求的话"]
    text_answer: Annotated[str | None, ..., "文本答案，如果用户要求的话"]
    reasoning: Annotated[str, ..., "答案背后的推理过程"]

agent = create_agent(
    model="gpt-4o-mini",
    tools=[code_tool, search_tool, polygon_aggregates],
    response_format=AgentOutputFormat,
    system_prompt="你是一名金融专家。准确回答用户的查询",
)
```

```typescript TypeScript
import { z } from "zod";
import { ChatOpenAI } from "@langchain/openai";
import { createReactAgent } from "@langchain/langgraph/prebuilt";

const AgentOutputFormatSchema = z.object({
  numeric_answer: z.number().optional().describe("The numeric answer, if the user asked for one"),
  text_answer: z.string().optional().describe("The text answer, if the user asked for one"),
  reasoning: z.string().describe("The reasoning behind the answer"),
})

const tools = [codeTool, searchTool, tickerTool];

const agent = createReactAgent({
  llm: new ChatOpenAI({ model: "gpt-4o" }),
  tools: tools,
  responseFormat: AgentOutputFormatSchema,
  stateModifier: "You are a financial expert. Respond to the users query accurately",
});

export default agent;
```

</CodeGroup>

## 编写测试

现在我们已经定义了智能体，让我们编写一些测试来确保基本功能。在本教程中，我们将测试智能体的工具调用能力是否正常工作，智能体是否知道忽略不相关的问题，以及它是否能够回答涉及使用所有工具的复杂问题。

我们首先需要设置一个测试文件，并在文件顶部添加所需的导入。

<CodeGroup>

```python Pytest
创建一个 `tests/test_agent.py` 文件。

from app import agent, polygon_aggregates, search_tool # 从您的智能体定义处导入
import pytest
from langsmith import testing as t
```

```typescript Vitest
将您的测试文件命名为 `agent.vitest.eval.ts`

import { expect } from "vitest";
import * as ls from "langsmith/vitest";
import agent from "../agent"; // 从您的智能体定义处导入

// 可选，但建议将测试分组
ls.describe("Agent Tests", () => {
  // 在此处放置测试
});
```

```typescript Jest
将您的测试文件命名为 `agent.jest.eval.ts`

import { expect } from "@jest/globals";
import * as ls from "langsmith/jest";
import agent from "../agent"; // 从您的智能体定义处导入

// 可选，但建议将测试分组
ls.describe("Agent Tests", () => {
  // 在此处放置测试
});
```

</CodeGroup>

### 测试 1：处理离题问题

第一个测试将是一个简单的检查，确保智能体不会在不相关的查询上使用工具。

<CodeGroup>

```python Pytest
@pytest.mark.langsmith
@pytest.mark.parametrize(
  # <-- 仍然可以使用所有普通的 pytest 标记
  "query",
  ["Hello!", "How are you doing?"],
)
def test_no_tools_on_offtopic_query(query: str) -> None:
  """测试智能体不会在离题查询上使用工具。"""
  # 记录测试示例
  t.log_inputs({"query": query})
  expected = []
  t.log_reference_outputs({"tool_calls": expected})
  # 直接调用智能体的模型节点，而不是运行 ReACT 循环。
  result = agent.nodes["agent"].invoke(
      {"messages": [{"role": "user", "content": query}]}
  )
  actual = result["messages"][0].tool_calls
  t.log_outputs({"tool_calls": actual})
  # 检查是否没有进行工具调用。
  assert actual == expected
```

```typescript Vitest
ls.test.each([
  { inputs: { query: "Hello!" }, expected: { numMessages: 2 } },
  { inputs: { query: "How are you doing?" }, expected: { numMessages: 2 } },
])(
  "should not use tools on offtopic query: %s",
  async ({ inputs: { query }, expected: { numMessages } }) => {
    const result = await agent.invoke({ messages: [{ role: "user", content: query }] });
    ls.logOutputs(result);

    // 检查流程是否为 HUMAN -> AI FINAL RESPONSE（未调用工具）
    expect(result.messages).toHaveLength(numMessages);
  }
);
```

```typescript Jest
ls.test.each([
  { inputs: { query: "Hello!" }, expected: { numMessages: 2 } },
  { inputs: { query: "How are you doing?" }, expected: { numMessages: 2 } },
])(
  "should not use tools on offtopic query: %s",
  async ({ inputs: { query }, expected: { numMessages } }) => {
    const result = await agent.invoke({ messages: [{ role: "user", content: query }] });
    ls.logOutputs(result);

    // 检查流程是否为 HUMAN -> AI FINAL RESPONSE（未调用工具）
    expect(result.messages).toHaveLength(numMessages);
  }
);
```

</CodeGroup>

### 测试 2：简单的工具调用

对于工具调用，我们将验证智能体是否使用正确的参数调用了正确的工具。

<CodeGroup>

```python Pytest
@pytest.mark.langsmith
def test_searches_for_correct_ticker() -> None:
  """测试模型在简单查询中查找正确的股票代码。"""
  # 记录测试示例
  query = "What is the price of Apple?"
  t.log_inputs({"query": query})
  expected = "AAPL"
  t.log_reference_outputs({"ticker": expected})
  # 直接调用智能体的模型节点，而不是运行完整的 ReACT 循环。
  result = agent.nodes["agent"].invoke(
      {"messages": [{"role": "user", "content": query}]}
  )
  tool_calls = result["messages"][0].tool_calls
  if tool_calls[0]["name"] == polygon_aggregates.name:
      actual = tool_calls[0]["args"]["ticker"]
  else:
      actual = None
  t.log_outputs({"ticker": actual})
  # 检查是否查询了正确的股票代码
  assert actual == expected
```

```typescript Vitest
ls.test(
  "should search for correct ticker",
  {
    inputs: { query: "What is the price of Apple?" },
    expected: { numMessages: 4 },
  },
  async ({ inputs: { query }, expected: { numMessages } }) => {
    const result = await agent.invoke({
      messages: [{ role: "user", content: query }],
    });

    ls.logOutputs(result);

    // 智能体应该对股票代码工具进行了一次工具调用
    const toolCalls = (result.messages[1] as AIMessage).tool_calls || [];
    const tickerQuery = JSON.parse(toolCalls[0].function.arguments).query.ticker;
    // 检查是否查询了正确的股票代码
    expect(tickerQuery).toBe("AAPL");

    // 检查流程是否为 HUMAN -> AI -> TOOL -> AI FINAL RESPONSE
    expect(result.messages).toHaveLength(numMessages);
  }
);
```

```typescript Jest
ls.test(
  "should search for correct ticker",
  {
    inputs: { query: "What is the price of Apple?" },
    expected: { numMessages: 4 },
  },
  async ({ inputs: { query }, expected: { numMessages } }) => {
    const result = await agent.invoke({
      messages: [{ role: "user", content: query }],
    });

    ls.logOutputs(result);

    // 智能体应该对股票代码工具进行了一次工具调用
    const toolCalls = (result.messages[1] as AIMessage).tool_calls || [];
    const tickerQuery = JSON.parse(toolCalls[0].function.arguments).query.ticker;
    // 检查是否查询了正确的股票代码
    expect(tickerQuery).toBe("AAPL");

    // 检查流程是否为 HUMAN -> AI -> TOOL -> AI FINAL RESPONSE
    expect(result.messages).toHaveLength(numMessages);
  }
);
```

</CodeGroup>

### 测试 3：复杂的工具调用

有些工具调用比其他工具更容易测试。对于股票代码查询，我们可以断言搜索了正确的股票代码。对于编码工具，工具的输入和输出约束要少得多，并且有很多方法可以得到正确答案。在这种情况下，通过运行完整的智能体并断言它既调用了编码工具，又最终得到了正确答案，来测试工具是否正确使用会更简单。

<CodeGroup>

```python Pytest
@pytest.mark.langsmith
def test_executes_code_when_needed() -> None:
  query = (
      "In the past year Facebook stock went up by 66.76%, "
      "Apple by 25.24%, Google by 37.11%, Amazon by 47.52%, "
      "Netflix by 78.31%. Whats the avg return in the past "
      "year of the FAANG stocks, expressed as a percentage?"
  )
  t.log_inputs({"query": query})
  expected = 50.988
  t.log_reference_outputs({"response": expected})
  # 测试智能体在需要时执行代码
  result = agent.invoke({"messages": [{"role": "user", "content": query}]})
  t.log_outputs({"result": result["structured_response"].get("numeric_answer")})
  # 获取 LLM 进行的所有工具调用
  tool_calls = [
      tc["name"]
      for msg in result["messages"]
      for tc in getattr(msg, "tool_calls", [])
  ]
  # 这将记录智能体采取的步骤数，有助于确定智能体获取答案的效率。
  t.log_feedback(key="num_steps", score=len(result["messages"]) - 1)
  # 断言使用了代码工具
  assert "code_tool" in tool_calls
  # 断言提供了数字答案：
  assert result["structured_response"].get("numeric_answer") is not None
  # 断言答案是正确的
  assert abs(result["structured_response"]["numeric_answer"] - expected) <= 0.01
```

```typescript Vitest
ls.test(
  "should execute code when needed",
  {
    inputs: { query: "What was the average return rate for FAANG stock in 2024?" },
    expected: { answer: 53 },
  },
  async ({ inputs: { query }, expected: { answer } }) => {
    const result = await agent.invoke({
      messages: [{ role: "user", content: query }],
    });

    ls.logOutputs(result);

    // 获取 LLM 进行的所有工具调用
    const toolCalls = result.messages
      .filter(m => (m as AIMessage).tool_calls)
      .flatMap(m => (m as AIMessage).tool_calls?.map(tc => tc.name));
    // 这将记录 LLM 采取的步骤数，我们可以随时间跟踪以衡量性能
    ls.logFeedback({
      key: "num_steps",
      score: result.messages.length - 1, //
