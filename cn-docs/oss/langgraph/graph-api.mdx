---
title: Graph API 概述
sidebarTitle: Graph API
---
## 图（Graphs）

LangGraph 的核心是将智能体（agent）工作流建模为图。你可以使用三个关键组件来定义智能体的行为：

1. [`State`](#state)：一个共享的数据结构，表示应用程序的当前快照。它可以是任何数据类型，但通常使用共享的状态模式（schema）来定义。

2. [`Nodes`](#nodes)：封装智能体逻辑的函数。它们接收当前状态作为输入，执行一些计算或产生副作用，并返回更新后的状态。

3. [`Edges`](#edges)：根据当前状态决定接下来执行哪个 `Node` 的函数。它们可以是条件分支或固定转换。

通过组合 `Nodes` 和 `Edges`，你可以创建随时间演变的复杂循环工作流。然而，真正的力量来自于 LangGraph 如何管理状态。

需要强调的是：`Nodes` 和 `Edges` 仅仅是函数——它们可以包含一个 LLM，也可以只是普通的代码。

简而言之：_节点执行工作，边决定下一步做什么_。

LangGraph 底层的图算法使用[消息传递](https://en.wikipedia.org/wiki/Message_passing)来定义一个通用程序。当一个节点完成其操作时，它会沿着一条或多条边向其他节点发送消息。这些接收节点然后执行它们的函数，将结果消息传递给下一组节点，这个过程持续进行。受 Google 的 [Pregel](https://research.google/pubs/pregel-a-system-for-large-scale-graph-processing/) 系统启发，程序以离散的“超级步（super-steps）”进行。

一个超级步可以被视为对图节点的一次迭代。并行运行的节点属于同一个超级步，而顺序运行的节点属于不同的超级步。在图执行开始时，所有节点都处于 `inactive` 状态。当一个节点在其任何入边（或“通道”）上接收到新消息（状态）时，它变为 `active`。然后，活动节点运行其函数并响应更新。在每个超级步结束时，没有收到消息的节点通过将自己标记为 `inactive` 来投票 `halt`。当所有节点都处于 `inactive` 状态且没有消息在传输中时，图执行终止。

### StateGraph

@[`StateGraph`] 类是主要使用的图类。它由用户定义的 `State` 对象参数化。

### 编译你的图

要构建你的图，你首先定义[状态](#state)，然后添加[节点](#nodes)和[边](#edges)，最后编译它。编译图到底是什么，为什么需要它？

编译是一个相当简单的步骤。它对你的图结构进行一些基本检查（例如，没有孤立的节点等）。这也是你可以指定运行时参数的地方，比如[检查点（checkpointers）](/oss/langgraph/persistence)和断点。你只需调用 `.compile` 方法来编译你的图：

:::python

```python
graph = graph_builder.compile(...)
```

:::

:::js

```typescript
const graph = new StateGraph(StateAnnotation)
  .addNode("nodeA", nodeA)
  .addEdge(START, "nodeA")
  .addEdge("nodeA", END)
  .compile();
```

:::

<Warning>
    在使用图之前，你**必须**编译它。
</Warning>

## 状态（State）

:::python
定义图时，你首先要做的是定义图的 `State`。`State` 由图的[模式（schema）](#schema)以及指定如何将更新应用到状态的[`reducer` 函数](#reducers)组成。`State` 的模式将是图中所有 `Nodes` 和 `Edges` 的输入模式，可以是 `TypedDict` 或 `Pydantic` 模型。所有 `Nodes` 都会发出对 `State` 的更新，然后使用指定的 `reducer` 函数来应用这些更新。
:::

:::js
定义图时，你首先要做的是定义图的 `State`。`State` 由图的[模式（schema）](#schema)以及指定如何将更新应用到状态的[`reducer` 函数](#reducers)组成。`State` 的模式将是图中所有 `Nodes` 和 `Edges` 的输入模式，可以是 Zod 模式或使用 `Annotation.Root` 构建的模式。所有 `Nodes` 都会发出对 `State` 的更新，然后使用指定的 `reducer` 函数来应用这些更新。
:::

### 模式（Schema）

:::python
指定图模式的主要文档化方法是使用 [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict)。如果你想在状态中提供默认值，请使用 [`dataclass`](https://docs.python.org/3/library/dataclasses.html)。如果你想要递归数据验证，我们也支持使用 Pydantic [`BaseModel`](/oss/langgraph/use-graph-api#use-pydantic-models-for-graph-state) 作为你的图状态（但请注意，Pydantic 的性能不如 `TypedDict` 或 `dataclass`）。

默认情况下，图将具有相同的输入和输出模式。如果你想改变这一点，也可以直接指定显式的输入和输出模式。当你有很多键，并且其中一些明确用于输入，另一些用于输出时，这很有用。有关更多信息，请参阅[指南](/oss/langgraph/use-graph-api#define-input-and-output-schemas)。
:::

:::js
指定图模式的主要文档化方法是使用 Zod 模式。但是，我们也支持使用 `Annotation` API 来定义图的模式。

默认情况下，图将具有相同的输入和输出模式。如果你想改变这一点，也可以直接指定显式的输入和输出模式。当你有很多键，并且其中一些明确用于输入，另一些用于输出时，这很有用。
:::

#### 多个模式

通常，所有图节点都使用单一模式进行通信。这意味着它们将读取和写入相同的状态通道。但是，有些情况下我们需要更多的控制：

- 内部节点可以传递图中输入/输出不需要的信息。
- 我们可能还想为图使用不同的输入/输出模式。例如，输出可能只包含一个相关的输出键。

可以让节点写入图内部的私有状态通道，用于内部节点通信。我们可以简单地定义一个私有模式 `PrivateState`。

也可以为图定义显式的输入和输出模式。在这些情况下，我们定义一个“内部”模式，其中包含与图操作相关的**所有**键。但是，我们还定义了 `input` 和 `output` 模式，它们是“内部”模式的子集，用于约束图的输入和输出。有关更多细节，请参阅[本指南](/oss/langgraph/graph-api#define-input-and-output-schemas)。

让我们看一个例子：

:::python

```python
class InputState(TypedDict):
    user_input: str

class OutputState(TypedDict):
    graph_output: str

class OverallState(TypedDict):
    foo: str
    user_input: str
    graph_output: str

class PrivateState(TypedDict):
    bar: str

def node_1(state: InputState) -> OverallState:
    # 写入 OverallState
    return {"foo": state["user_input"] + " name"}

def node_2(state: OverallState) -> PrivateState:
    # 从 OverallState 读取，写入 PrivateState
    return {"bar": state["foo"] + " is"}

def node_3(state: PrivateState) -> OutputState:
    # 从 PrivateState 读取，写入 OutputState
    return {"graph_output": state["bar"] + " Lance"}

builder = StateGraph(OverallState,input_schema=InputState,output_schema=OutputState)
builder.add_node("node_1", node_1)
builder.add_node("node_2", node_2)
builder.add_node("node_3", node_3)
builder.add_edge(START, "node_1")
builder.add_edge("node_1", "node_2")
builder.add_edge("node_2", "node_3")
builder.add_edge("node_3", END)

graph = builder.compile()
graph.invoke({"user_input":"My"})
# {'graph_output': 'My name is Lance'}
```

:::

:::js

```typescript
const InputState = z.object({
  userInput: z.string(),
});

const OutputState = z.object({
  graphOutput: z.string(),
});

const OverallState = z.object({
  foo: z.string(),
  userInput: z.string(),
  graphOutput: z.string(),
});

const PrivateState = z.object({
  bar: z.string(),
});

const graph = new StateGraph({
  state: OverallState,
  input: InputState,
  output: OutputState,
})
  .addNode("node1", (state) => {
    // 写入 OverallState
    return { foo: state.userInput + " name" };
  })
  .addNode("node2", (state) => {
    // 从 OverallState 读取，写入 PrivateState
    return { bar: state.foo + " is" };
  })
  .addNode(
    "node3",
    (state) => {
      // 从 PrivateState 读取，写入 OutputState
      return { graphOutput: state.bar + " Lance" };
    },
    { input: PrivateState }
  )
  .addEdge(START, "node1")
  .addEdge("node1", "node2")
  .addEdge("node2", "node3")
  .addEdge("node3", END)
  .compile();

await graph.invoke({ userInput: "My" });
// { graphOutput: 'My name is Lance' }
```

:::

这里有两个微妙而重要的点需要注意：

:::python

1.  我们将 `state: InputState` 作为输入模式传递给 `node_1`。但是，我们写出到 `foo`，这是 `OverallState` 中的一个通道。我们如何写出到输入模式中未包含的状态通道？这是因为一个节点**可以写入图状态中的任何状态通道**。图状态是在初始化时定义的状态通道的并集，其中包括 `OverallState` 以及过滤器 `InputState` 和 `OutputState`。

2.  我们使用以下方式初始化图：

    ```python
    StateGraph(
        OverallState,
        input_schema=InputState,
        output_schema=OutputState
    )
    ```

    那么，我们如何在 `node_2` 中写入 `PrivateState`？如果 `PrivateState` 没有在 `StateGraph` 初始化时传入，图如何获得对这个模式的访问权限？

    我们可以这样做，因为 `_nodes` 也可以声明额外的状态 `channels_`，只要状态模式定义存在。在这种情况下，`PrivateState` 模式已定义，因此我们可以将 `bar` 作为图中的新状态通道添加并写入它。
:::

:::js

1.  我们将 `state` 作为输入模式传递给 `node1`。但是，我们写出到 `foo`，这是 `OverallState` 中的一个通道。我们如何写出到输入模式中未包含的状态通道？这是因为一个节点**可以写入图状态中的任何状态通道**。图状态是在初始化时定义的状态通道的并集，其中包括 `OverallState` 以及过滤器 `InputState` 和 `OutputState`。

2.  我们使用 `StateGraph({ state: OverallState, input: InputState, output: OutputState })` 初始化图。那么，我们如何在 `node2` 中写入 `PrivateState`？如果 `PrivateState` 没有在 `StateGraph` 初始化时传入，图如何获得对这个模式的访问权限？我们可以这样做，因为**节点也可以声明额外的状态通道**，只要状态模式定义存在。在这种情况下，`PrivateState` 模式已定义，因此我们可以将 `bar` 作为图中的新状态通道添加并写入它。
:::

### 归约器（Reducers）

归约器是理解节点更新如何应用到 `State` 的关键。`State` 中的每个键都有其独立的归约器函数。如果没有显式指定归约器函数，则假定对该键的所有更新都应覆盖它。有几种不同类型的归约器，首先是默认类型：

#### 默认归约器

这两个例子展示了如何使用默认归约器：

:::python

```python Example A
from typing_extensions import TypedDict

class State(TypedDict):
    foo: int
    bar: list[str]
```

:::

:::js

```typescript Example A
const State = z.object({
  foo: z.number(),
  bar: z.array(z.string()),
});
```

:::

在这个例子中，没有为任何键指定归约器函数。假设图的输入是：

:::python
`{"foo": 1, "bar": ["hi"]}`。然后假设第一个 `Node` 返回 `{"foo": 2}`。这被视为对状态的更新。注意，`Node` 不需要返回整个 `State` 模式——只需要一个更新。应用此更新后，`State` 将变为 `{"foo": 2, "bar": ["hi"]}`。如果第二个节点返回 `{"bar": ["bye"]}`，那么 `State` 将变为 `{"foo": 2, "bar": ["bye"]}`
:::

:::js
`{ foo: 1, bar: ["hi"] }`。然后假设第一个 `Node` 返回 `{ foo: 2 }`。这被视为对状态的更新。注意，`Node` 不需要返回整个 `State` 模式——只需要一个更新。应用此更新后，`State` 将变为 `{ foo: 2, bar: ["hi"] }`。如果第二个节点返回 `{ bar: ["bye"] }`，那么 `State` 将变为 `{ foo: 2, bar: ["bye"] }`
:::

:::python

```python Example B
from typing import Annotated
from typing_extensions import TypedDict
from operator import add

class State(TypedDict):
    foo: int
    bar: Annotated[list[str], add]
```

在这个例子中，我们使用了 `Annotated` 类型来为第二个键（`bar`）指定一个归约器函数（`operator.add`）。注意第一个键保持不变。假设图的输入是 `{"foo": 1, "bar": ["hi"]}`。然后假设第一个 `Node` 返回 `{"foo": 2}`。这被视为对状态的更新。注意，`Node` 不需要返回整个 `State` 模式——只需要一个更新。应用此更新后，`State` 将变为 `{"foo": 2, "bar": ["hi"]}`。如果第二个节点返回 `{"bar": ["bye"]}`，那么 `State` 将变为 `{"foo": 2, "bar": ["hi", "bye"]}`。注意这里 `bar` 键是通过将两个列表相加来更新的。
:::

:::js

```typescript Example B
import * as z from "zod";
import { registry } from "@langchain/langgraph/zod";

const State = z.object({
  foo: z.number(),
  bar: z.array(z.string()).register(registry, {
    reducer: {
      fn: (x, y) => x.concat(y),
    },
    default: () => [] as string[],
  }),
});
```

在这个例子中，我们使用了 [Zod 4 注册表](https://zod.dev/metadata) 来为第二个键（`bar`）指定一个归约器函数。注意第一个键保持不变。假设图的输入是 `{ foo: 1, bar: ["hi"] }`。然后假设第一个 `Node` 返回 `{ foo: 2 }`。这被视为对状态的更新。注意，`Node` 不需要返回整个 `State` 模式——只需要一个更新。应用此更新后，`State` 将变为 `{ foo: 2, bar: ["hi"] }`。如果第二个节点返回 `{ bar: ["bye"] }`，那么 `State` 将变为 `{ foo: 2, bar: ["hi", "bye"] }`。注意这里 `bar` 键是通过将两个数组连接在一起来更新的。
:::

:::python
#### 覆盖（Overwrite）
<Tip>
在某些情况下，你可能希望绕过归约器并直接覆盖状态值。LangGraph 为此提供了 [`Overwrite`](https://reference.langchain.com/python/langgraph/types/) 类型。[在此了解如何使用 `Overwrite`](/oss/langgraph/use-graph-api#bypass-reducers-with-overwrite)。
</Tip>
:::

### 在图状态中使用消息（Messages）

#### 为什么使用消息？

大多数现代 LLM 提供商都有一个聊天模型接口，接受消息列表作为输入。特别是 LangChain 的[聊天模型接口](/oss/langchain/models)接受消息对象列表作为输入。这些消息有多种形式，例如 @[`HumanMessage`]（用户输入）或 @[`AIMessage`]（LLM 响应）。

要了解更多关于消息对象的信息，请参阅[消息概念指南](/oss/langchain/messages)。

#### 在你的图中使用消息

:::python
在许多情况下，将先前的对话历史记录作为消息列表存储在图形状态中是很有帮助的。为此，我们可以向图状态添加一个键（通道），用于存储 `Message` 对象列表，并使用归约器函数对其进行注释（参见下面的示例中的 `messages` 键）。归约器函数对于告诉图如何用每个状态更新（例如，当节点发送更新时）来更新状态中的 `Message` 对象列表至关重要。如果你不指定归约器，每次状态更新都会用最近提供的值覆盖消息列表。如果你想简单地将消息追加到现有列表中，可以使用 `operator.add` 作为归约器。

但是，你可能还想手动更新图状态中的消息（例如，人在回路中）。如果你使用 `operator.add`，你发送到图的手动状态更新将被追加到现有的消息列表中，而不是更新现有消息。为了避免这种情况，你需要一个能够跟踪消息 ID 并在更新时覆盖现有消息的归约器。为了实现这一点，你可以使用预构建的 @[`add_messages`] 函数。对于全新的消息，它只会简单地追加到现有列表中，但它也会正确处理现有消息的更新。
:::

:::js
在许多情况下，将先前的对话历史记录作为消息列表存储在图形状态中是很有帮助的。为此，我们可以向图状态添加一个键（通道），用于存储 `Message` 对象列表，并使用归约器函数对其进行注释（参见下面的示例中的 `messages` 键）。归约器函数对于告诉图如何用每个状态更新（例如，当节点发送更新时）来更新状态中的 `Message` 对象列表至关重要。如果你不指定归约器，每次状态更新都会用最近提供的值覆盖消息列表。如果你想简单地将消息追加到现有列表中，可以使用一个连接数组的函数作为归约器。

但是，你可能还想手动更新图状态中的消息（例如，人在回路中）。如果你使用简单的连接函数，你发送到图的手动状态更新将被追加到现有的消息列表中，而不是更新现有消息。为了避免这种情况，你需要一个能够跟踪消息 ID 并在更新时覆盖现有消息的归约器。为了实现这一点，你可以使用预构建的 `messagesStateReducer` 函数，或者当状态模式使用 Zod 定义时使用 `MessagesZodMeta`。对于
