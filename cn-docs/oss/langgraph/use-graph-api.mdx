---
title: 使用图 API
sidebarTitle: Use the graph API
---
import ChatModelTabs from '/snippets/chat-model-tabs.mdx';

本指南演示了 LangGraph Graph API 的基础知识。它将引导您了解[状态](#define-and-update-state)，以及如何组合常见的图结构，例如[序列](#create-a-sequence-of-steps)、[分支](#create-branches)和[循环](#create-and-control-loops)。它还涵盖了 LangGraph 的控制功能，包括用于 map-reduce 工作流的[Send API](#map-reduce-and-the-send-api)，以及用于将状态更新与跨节点“跳转”相结合的[Command API](#combine-control-flow-and-state-updates-with-command)。

## 设置

:::python
安装 `langgraph`：

<CodeGroup>
```bash pip
pip install -U langgraph
```

```bash uv
uv add langgraph
```
</CodeGroup>
:::

:::js
安装 `langgraph`：

```bash
npm install @langchain/langgraph
```
:::

<Tip>
**设置 LangSmith 以获得更好的调试体验**

注册 [LangSmith](https://smith.langchain.com) 以快速发现问题并提升 LangGraph 项目的性能。LangSmith 允许您使用追踪数据来调试、测试和监控您使用 LangGraph 构建的 LLM 应用——有关如何开始的更多信息，请参阅[文档](/langsmith/observability)。
</Tip>

## 定义和更新状态

这里我们将展示如何在 LangGraph 中定义和更新[状态](/oss/langgraph/graph-api#state)。我们将演示：

1. 如何使用状态定义图的[模式（schema）](/oss/langgraph/graph-api#schema)
2. 如何使用[归约器（reducers）](/oss/langgraph/graph-api#reducers)来控制状态更新的处理方式。

### 定义状态

:::python
LangGraph 中的[状态](/oss/langgraph/graph-api#state)可以是 `TypedDict`、`Pydantic` 模型或数据类。下面我们将使用 `TypedDict`。有关使用 Pydantic 的详细信息，请参阅[此部分](#use-pydantic-models-for-graph-state)。
:::

:::js
LangGraph 中的[状态](/oss/langgraph/graph-api#state)可以使用 Zod 模式定义。下面我们将使用 Zod。有关使用替代方法的详细信息，请参阅[此部分](#alternative-state-definitions)。
:::

默认情况下，图将具有相同的输入和输出模式，状态决定了该模式。有关如何定义不同的输入和输出模式，请参阅[此部分](#define-input-and-output-schemas)。

让我们考虑一个使用[消息（messages）](/oss/langgraph/graph-api#messagesstate)的简单示例。这代表了适用于许多 LLM 应用的状态的通用形式。更多细节请参阅我们的[概念页面](/oss/langgraph/graph-api#working-with-messages-in-graph-state)。

:::python
```python
from langchain.messages import AnyMessage
from typing_extensions import TypedDict

class State(TypedDict):
    messages: list[AnyMessage]
    extra_field: int
```

此状态跟踪一个[消息](https://python.langchain.com/docs/concepts/messages/)对象列表，以及一个额外的整数字段。
:::

:::js
```typescript
import { BaseMessage } from "@langchain/core/messages";
import { MessagesZodMeta } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  messages: z.array(z.custom<BaseMessage>()).register(registry, MessagesZodMeta),
  extraField: z.number(),
});
```

此状态跟踪一个[消息](https://js.langchain.com/docs/concepts/messages/)对象列表，以及一个额外的整数字段。
:::

### 更新状态

:::python
让我们构建一个包含单个节点的示例图。我们的[节点](/oss/langgraph/graph-api#nodes)只是一个 Python 函数，它读取图的状态并对其进行更新。此函数的第一个参数始终是状态：

```python
from langchain.messages import AIMessage

def node(state: State):
    messages = state["messages"]
    new_message = AIMessage("Hello!")
    return {"messages": messages + [new_message], "extra_field": 10}
```

此节点只是向我们的消息列表追加一条消息，并填充一个额外字段。
:::

:::js
让我们构建一个包含单个节点的示例图。我们的[节点](/oss/langgraph/graph-api#nodes)只是一个 TypeScript 函数，它读取图的状态并对其进行更新。此函数的第一个参数始终是状态：

```typescript
import { AIMessage } from "@langchain/core/messages";

const node = (state: z.infer<typeof State>) => {
  const messages = state.messages;
  const newMessage = new AIMessage("Hello!");
  return { messages: messages.concat([newMessage]), extraField: 10 };
};
```

此节点只是向我们的消息列表追加一条消息，并填充一个额外字段。
:::

<Warning>
节点应直接返回对状态的更新，而不是直接修改状态。
</Warning>

:::python
接下来，让我们定义一个包含此节点的简单图。我们使用 [`StateGraph`](/oss/langgraph/graph-api#stategraph) 来定义一个在此状态上操作的图。然后使用 [`add_node`](/oss/langgraph/graph-api#nodes) 填充我们的图。

```python
from langgraph.graph import StateGraph

builder = StateGraph(State)
builder.add_node(node)
builder.set_entry_point("node")
graph = builder.compile()
```
:::

:::js
接下来，让我们定义一个包含此节点的简单图。我们使用 [`StateGraph`](/oss/langgraph/graph-api#stategraph) 来定义一个在此状态上操作的图。然后使用 [`addNode`](/oss/langgraph/graph-api#nodes) 填充我们的图。

```typescript
import { StateGraph } from "@langchain/langgraph";

const graph = new StateGraph(State)
  .addNode("node", node)
  .addEdge("__start__", "node")
  .compile();
```
:::

LangGraph 提供了内置工具来可视化您的图。让我们检查一下我们的图。有关可视化的详细信息，请参阅[此部分](#visualize-your-graph)。

:::python
```python
from IPython.display import Image, display

display(Image(graph.get_graph().draw_mermaid_png()))
```

![包含单个节点的简单图](/oss/images/graph_api_image_1.png)
:::

:::js
```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```
:::

在这种情况下，我们的图只执行一个节点。让我们进行一个简单的调用：

:::python
```python
from langchain.messages import HumanMessage

result = graph.invoke({"messages": [HumanMessage("Hi")]})
result
```

```
{'messages': [HumanMessage(content='Hi'), AIMessage(content='Hello!')], 'extra_field': 10}
```
:::

:::js
```typescript
import { HumanMessage } from "@langchain/core/messages";

const result = await graph.invoke({ messages: [new HumanMessage("Hi")], extraField: 0 });
console.log(result);
```

```
{ messages: [HumanMessage { content: 'Hi' }, AIMessage { content: 'Hello!' }], extraField: 10 }
```
:::

请注意：

* 我们通过更新状态的单个键来启动调用。
* 我们在调用结果中接收到完整的状态。

:::python
为了方便起见，我们经常通过美化打印来检查[消息对象](https://python.langchain.com/docs/concepts/messages/)的内容：

```python
for message in result["messages"]:
    message.pretty_print()
```

```
================================ Human Message ================================

Hi
================================== Ai Message ==================================

Hello!
```
:::

:::js
为了方便起见，我们经常通过日志记录来检查[消息对象](https://js.langchain.com/docs/concepts/messages/)的内容：

```typescript
for (const message of result.messages) {
  console.log(`${message.getType()}: ${message.content}`);
}
```

```
human: Hi
ai: Hello!
```
:::

### 使用归约器处理状态更新

状态中的每个键都可以有自己独立的[归约器（reducer）](/oss/langgraph/graph-api#reducers)函数，它控制来自节点的更新如何被应用。如果没有显式指定归约器函数，则假定对该键的所有更新都应覆盖它。

:::python
对于 `TypedDict` 状态模式，我们可以通过用归约器函数注解状态的相应字段来定义归约器。

在之前的示例中，我们的节点通过向其中追加消息来更新状态中的 `"messages"` 键。下面，我们为此键添加一个归约器，以便更新自动追加：

```python
from typing_extensions import Annotated

def add(left, right):
    """也可以从内置的 `operator` 模块导入 `add`。"""
    return left + right

class State(TypedDict):
    messages: Annotated[list[AnyMessage], add]  # [!code highlight]
    extra_field: int
```

现在我们的节点可以简化：

```python
def node(state: State):
    new_message = AIMessage("Hello!")
    return {"messages": [new_message], "extra_field": 10}  # [!code highlight]
```
:::

:::js
对于 Zod 状态模式，我们可以通过在模式字段上使用特殊的 `.langgraph.reducer()` 方法来定义归约器。

在之前的示例中，我们的节点通过向其中追加消息来更新状态中的 `"messages"` 键。下面，我们为此键添加一个归约器，以便更新自动追加：

```typescript
import "@langchain/langgraph/zod";

const State = z.object({
  messages: z.array(z.custom<BaseMessage>()).langgraph.reducer((x, y) => x.concat(y)),  // [!code highlight]
  extraField: z.number(),
});
```

现在我们的节点可以简化：

```typescript
const node = (state: z.infer<typeof State>) => {
  const newMessage = new AIMessage("Hello!");
  return { messages: [newMessage], extraField: 10 };  // [!code highlight]
};
```
:::

:::python
```python
from langgraph.graph import START

graph = StateGraph(State).add_node(node).add_edge(START, "node").compile()

result = graph.invoke({"messages": [HumanMessage("Hi")]})

for message in result["messages"]:
    message.pretty_print()
```

```
================================ Human Message ================================

Hi
================================== Ai Message ==================================

Hello!
```
:::

:::js
```typescript
import { START } from "@langchain/langgraph";

const graph = new StateGraph(State)
  .addNode("node", node)
  .addEdge(START, "node")
  .compile();

const result = await graph.invoke({ messages: [new HumanMessage("Hi")] });

for (const message of result.messages) {
  console.log(`${message.getType()}: ${message.content}`);
}
```

```
human: Hi
ai: Hello!
```
:::

#### MessagesState

在实践中，更新消息列表还有其他考虑因素：

* 我们可能希望更新状态中的现有消息。
* 我们可能希望接受[消息格式](/oss/langgraph/graph-api#using-messages-in-your-graph)的简写，例如 [OpenAI 格式](https://python.langchain.com/docs/concepts/messages/#openai-format)。

:::python
LangGraph 包含一个内置的归约器 @[`add_messages`]，它处理这些考虑因素：

```python
from langgraph.graph.message import add_messages

class State(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]  # [!code highlight]
    extra_field: int

def node(state: State):
    new_message = AIMessage("Hello!")
    return {"messages": [new_message], "extra_field": 10}

graph = StateGraph(State).add_node(node).set_entry_point("node").compile()
```

```python
input_message = {"role": "user", "content": "Hi"}  # [!code highlight]

result = graph.invoke({"messages": [input_message]})

for message in result["messages"]:
    message.pretty_print()
```

```
================================ Human Message ================================

Hi
================================== Ai Message ==================================

Hello!
```

这是涉及[聊天模型](https://python.langchain.com/docs/concepts/chat_models/)的应用程序状态的通用表示。LangGraph 包含一个预构建的 `MessagesState` 以方便使用，这样我们就可以拥有：

```python
from langgraph.graph import MessagesState

class State(MessagesState):
    extra_field: int
```
:::

:::js
LangGraph 包含一个内置的 `MessagesZodMeta`，它处理这些考虑因素：

```typescript
import { MessagesZodMeta } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({  // [!code highlight]
  messages: z
    .array(z.custom<BaseMessage>())
    .register(registry, MessagesZodMeta),
  extraField: z.number(),
});

const graph = new StateGraph(State)
  .addNode("node", (state) => {
    const newMessage = new AIMessage("Hello!");
    return { messages: [newMessage], extraField: 10 };
  })
  .addEdge(START, "node")
  .compile();
```

```typescript
const inputMessage = { role: "user", content: "Hi" };  // [!code highlight]

const result = await graph.invoke({ messages: [inputMessage] });

for (const message of result.messages) {
  console.log(`${message.getType()}: ${message.content}`);
}
```

```
human: Hi
ai: Hello!
```

这是涉及[聊天模型](https://js.langchain.com/docs/concepts/chat_models/)的应用程序状态的通用表示。LangGraph 包含这个预构建的 `MessagesZodMeta` 以方便使用，这样我们就可以拥有：

```typescript
import { MessagesZodMeta } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  messages: z
    .array(z.custom<BaseMessage>())
    .register(registry, MessagesZodMeta),
  extraField: z.number(),
});
```
:::

:::python
### 使用 `Overwrite` 绕过归约器

在某些情况下，您可能希望绕过归约器并直接覆盖状态值。LangGraph 为此提供了 [`Overwrite`](https://reference.langchain.com/python/langgraph/types/) 类型。当节点返回一个用 `Overwrite` 包装的值时，归约器将被绕过，通道将直接设置为该值。

当您想要重置或替换累积的状态而不是将其与现有值合并时，这很有用。

```python
from langgraph.graph import StateGraph, START, END
from langgraph.types import Overwrite
from typing_extensions import Annotated, TypedDict
import operator

class State(TypedDict):
    messages: Annotated[list, operator.add]

def add_message(state: State):
    return {"messages": ["first message"]}

def replace_messages(state: State):
    # 绕过归约器并替换整个消息列表
    return {"messages": Overwrite(["replacement message"])}

builder = StateGraph(State)
builder.add_node("add_message", add_message)
builder.add_node("replace_messages", replace_messages)
builder.add_edge(START, "add_message")
builder.add_edge("add_message", "replace_messages")
builder.add_edge("replace_messages", END)

graph = builder.compile()

result = graph.invoke({"messages": ["initial"]})
print(result["messages"])
```

```
['replacement message']
```

您也可以使用带有特殊键 `"__overwrite__"` 的 JSON 格式：

```python
def replace_messages(state: State):
    return {"messages": {"__overwrite__": ["replacement message"]}}
```

<Warning>
当节点并行执行时，在给定的超步（super-step）中，只有一个节点可以对同一状态键使用 `Overwrite`。如果多个节点在同一超步中尝试覆盖同一键，将引发 `InvalidUpdateError`。
</Warning>
:::

### 定义输入和输出模式

默认情况下，`StateGraph` 使用单一模式运行，所有节点都期望使用该模式进行通信。但是，也可以为图定义不同的输入和输出模式。

当指定了不同的模式时，节点之间的通信仍将使用内部模式。输入模式确保提供的输入符合预期的结构，而输出模式则根据定义的输出模式过滤内部数据，仅返回相关信息。

下面，我们将看到如何定义不同的输入和输出模式。

:::python
```python
from langgraph.graph import StateGraph, START, END
from typing_extensions import TypedDict

# 定义输入的模式
class InputState(TypedDict):
    question: str

# 定义输出的模式
class OutputState(TypedDict):
    answer: str

# 定义整体模式，结合输入和输出
class OverallState(InputState, OutputState):
    pass

# 定义处理输入并生成答案的节点
def answer_node(state: InputState):
    # 示例答案和一个额外键
    return {"answer": "bye", "question": state["question"]}

# 构建图，指定输入和输出模式
builder = StateGraph(OverallState, input_schema=InputState, output_schema=OutputState)
builder.add_node(answer_node)  # 添加答案节点
builder.add_edge(START, "answer_node")  # 定义起始边
builder.add_edge("answer_node", END)  # 定义结束边
graph = builder.compile()  # 编译图

# 使用输入调用图并打印结果
print(graph.invoke({"question": "hi"}))
```

```
{'answer': 'bye'}
```
:::

:::js
```typescript
import { StateGraph, START, END } from "@langchain/langgraph";
import * as z from "zod";

// 定义输入的模式
const InputState = z.object({
  question: z.string(),
});

// 定义输出的模式
const OutputState = z.object({
  answer: z.string(),
});

// 定义整体模式，结合输入和输出
const OverallState = InputState.merge(OutputState);

// 构建图，指定输入和输出模式
const graph = new StateGraph({
  input: InputState,
  output: OutputState,
  state: OverallState,
})
  .addNode("answerNode", (state) => {
    // 示例答案和一个额外键
    return { answer: "bye", question: state.question };
  })
  .addEdge(START, "answerNode")
  .addEdge("
