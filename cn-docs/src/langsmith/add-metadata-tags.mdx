---
title: 为追踪添加元数据和标签
sidebarTitle: Add metadata and tags to traces
---
LangSmith 支持在发送追踪记录时附带任意的元数据和标签。

标签是可用于对追踪记录进行分类或标记的字符串。元数据是键值对字典，可用于存储有关追踪记录的附加信息。

两者都可用于将附加信息与追踪记录关联起来，例如执行环境、发起用户或内部关联 ID。有关标签和元数据的更多信息，请参阅[概念](/langsmith/observability-concepts#tags)页面。有关如何按元数据和标签查询追踪记录和运行的信息，请参阅[在应用程序中筛选追踪记录](/langsmith/filter-traces-in-application)页面。

<CodeGroup>

```python Python
import openai
import langsmith as ls
from langsmith.wrappers import wrap_openai

client = openai.Client()
messages = [
    {"role": "system", "content": "You are a helpful assistant."},
    {"role": "user", "content": "Hello!"}
]

    # 您可以在装饰函数时**静态地**设置元数据和标签
    # 使用带有标签和元数据的 @traceable 装饰器
    # 确保设置了 LANGSMITH_TRACING 环境变量以使 @traceable 生效
    @ls.traceable(
        run_type="llm",
        name="OpenAI Call Decorator",
        tags=["my-tag"],
        metadata={"my-key": "my-value"}
    )
    def call_openai(
        messages: list[dict], model: str = "gpt-4o-mini"
    ) -> str:
        # 您也可以在父级运行上动态设置元数据：
        rt = ls.get_current_run_tree()
        rt.metadata["some-conditional-key"] = "some-val"
        rt.tags.extend(["another-tag"])
        return client.chat.completions.create(
            model=model,
            messages=messages,
        ).choices[0].message.content

    call_openai(
        messages,
        # 要在**调用时**添加，可以在调用函数时
        # 通过 langsmith_extra 参数实现
        langsmith_extra={"tags": ["my-other-tag"], "metadata": {"my-other-key": "my-value"}}
    )

    # 或者，您可以使用上下文管理器
    with ls.trace(
        name="OpenAI Call Trace",
        run_type="llm",
        inputs={"messages": messages},
        tags=["my-tag"],
        metadata={"my-key": "my-value"},
    ) as rt:
        chat_completion = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=messages,
        )
        rt.metadata["some-conditional-key"] = "some-val"
        rt.end(outputs={"output": chat_completion})

# 您可以在包装后的客户端上使用相同的技术
patched_client = wrap_openai(
    client, tracing_extra={"metadata": {"my-key": "my-value"}, "tags": ["a-tag"]}
)
chat_completion = patched_client.chat.completions.create(
    model="gpt-4o-mini",
    messages=messages,
    langsmith_extra={
        "tags": ["my-other-tag"],
        "metadata": {"my-other-key": "my-value"},
    },
)
```

```typescript TypeScript
import OpenAI from "openai";
import { traceable, getCurrentRunTree } from "langsmith/traceable";
import { wrapOpenAI } from "langsmith/wrappers";

    const client = wrapOpenAI(new OpenAI());
    const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [
        { role: "system", content: "You are a helpful assistant." },
        { role: "user", content: "Hello!" },
    ];

    const traceableCallOpenAI = traceable(
        async (messages: OpenAI.Chat.ChatCompletionMessageParam[]) => {
            const completion = await client.chat.completions.create({
                model: "gpt-4o-mini",
                messages,
            });
            const runTree = getCurrentRunTree();
            runTree.extra.metadata = {
                ...runTree.extra.metadata,
                someKey: "someValue",
            };
            runTree.tags = [...(runTree.tags ?? []), "runtime-tag"];
            return completion.choices[0].message.content;
        },
        {
            run_type: "llm",
            name: "OpenAI Call Traceable",
            tags: ["my-tag"],
            metadata: { "my-key": "my-value" },
        }
    );

// 调用可追踪函数
await traceableCallOpenAI(messages);
```

</CodeGroup>
