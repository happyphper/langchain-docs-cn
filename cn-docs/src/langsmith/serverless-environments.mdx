---
title: 在无服务器环境中追踪 JavaScript 函数
sidebarTitle: Trace JS functions in serverless environments
---
<Note>
本节内容适用于使用 LangSmith JS SDK 0.2.0 及更高版本的用户。如果您在无服务器环境中使用 LangChain.js 或 LangGraph.js 进行追踪，请参阅[此指南](https://js.langchain.com/docs/how_to/callbacks_serverless)。
</Note>

在追踪 JavaScript 函数时，LangSmith 默认会在后台追踪运行，以避免增加延迟。在无服务器环境中，执行上下文可能会突然终止，因此确保在函数完成前正确刷新所有追踪数据非常重要。

为确保这一点，您可以：

* 设置一个名为 `LANGSMITH_TRACING_BACKGROUND` 的环境变量为 `"false"`。这将使您的被追踪函数在返回前等待追踪完成。
  * 请注意，此变量名称与 LangChain.js 中的[环境变量](https://js.langchain.com/docs/how_to/callbacks_serverless)不同，因为 LangSmith 可以在不使用 LangChain 的情况下使用。
* 将自定义客户端传入您的追踪运行，并 `await` `client.awaitPendingTraceBatches();` 方法。

以下是一个结合使用 `awaitPendingTraceBatches` 和 [`traceable`](/langsmith/annotate-code) 方法的示例：

```typescript
import { Client } from "langsmith";
import { traceable } from "langsmith/traceable";
const langsmithClient = new Client({});
const tracedFn = traceable(
  async () => {
    return "Some return value";
  },
  {
    client: langsmithClient,
  }
);
const res = await tracedFn();
await langsmithClient.awaitPendingTraceBatches();
```

## 高并发下的速率限制[](#rate-limits-at-high-concurrency "Direct link to Rate limits at high concurrency")

默认情况下，LangSmith 客户端会在您的追踪运行执行时批量处理操作，每隔几毫秒发送一个新的批次。

这在大多数情况下效果良好，但如果您的被追踪函数运行时间较长且并发量非常高，您也可能会遇到与总请求数相关的速率限制。

如果您看到与此相关的速率限制错误，可以尝试在客户端中设置 `manualFlushMode: true`，如下所示：

```typescript
import { Client } from "langsmith";
const langsmithClient = new Client({  manualFlushMode: true,});
const myTracedFunc = traceable(
  async () => {
    // 您的逻辑在这里...
  },
  { client: langsmithClient }
);
```

然后在您的无服务器函数关闭前手动调用 `client.flush()`，如下所示：

```typescript
try {
  await myTracedFunc();
} finally {
  await langsmithClient.flush();
}
```

请注意，这将导致运行在您调用 `.flush()` 之前不会出现在 LangSmith UI 中。
