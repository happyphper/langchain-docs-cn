---
title: LangChain v1 有哪些新特性
sidebarTitle: LangChain v1
---
**LangChain v1 是一个专注于构建智能体（agent）的生产就绪基础框架。** 我们围绕三个核心改进简化了框架：

<CardGroup cols={1}>
    <Card title="createAgent" icon="robot" href="#create-agent" arrow>
        在 LangChain 中构建智能体的新标准方式，用更简洁、更强大的 API 取代了 LangGraph 中的 `createReactAgent`。
    </Card>
    <Card title="标准内容块" icon="cube" href="#standard-content-blocks" arrow>
        新的 `contentBlocks` 属性，为所有提供商提供对现代 LLM 功能的统一访问。
    </Card>
    <Card title="简化的包" icon="sitemap" href="#simplified-package" arrow>
        `langchain` 包已简化，专注于智能体的核心构建模块，遗留功能已移至 `@langchain/classic`。
    </Card>
</CardGroup>

要升级，请执行：

<CodeGroup>
```bash npm
npm install langchain @langchain/core
```
```bash pnpm
pnpm install langchain @langchain/core
```
```bash yarn
yarn add langchain @langchain/core
```
```bash bun
bun add langchain @langchain/core
```
</CodeGroup>

有关完整的变更列表，请参阅 [迁移指南](/oss/migrate/langchain-v1)。

## `createAgent`

`createAgent` 是 LangChain 1.0 中构建智能体的标准方式。它提供了比从 LangGraph 导出的预构建 `createReactAgent` 更简单的接口，同时通过使用中间件提供了更大的自定义潜力。

```ts
import { createAgent } from "langchain";

const agent = createAgent({
  model: "claude-sonnet-4-5-20250929",
  tools: [getWeather],
  systemPrompt: "You are a helpful assistant.",
});

const result = await agent.invoke({
  messages: [
    { role: "user", content: "What is the weather in Tokyo?" },
  ],
});

console.log(result.content);
```

在底层，`createAgent` 构建于基本的智能体循环之上——调用模型，让它选择要执行的工具，然后在它不再调用工具时结束：

<div style={{ display: "flex", justifyContent: "center" }}>
  <img
    src="/oss/images/core_agent_loop.png"
    alt="核心智能体循环示意图"
    className="rounded-lg"
  />
</div>

更多信息，请参阅 [智能体](/oss/langchain/agents)。

### 中间件

中间件是 `createAgent` 的定义性特性。它使 `createAgent` 高度可定制，提升了你能构建的功能上限。

优秀的智能体需要 [上下文工程](/oss/langchain/context-engineering)：在正确的时间将正确的信息传递给模型。中间件通过一个可组合的抽象，帮助你控制动态提示、对话摘要、选择性工具访问、状态管理和防护栏。

#### 预构建中间件

LangChain 为常见模式提供了一些 [预构建中间件](/oss/langchain/middleware#built-in-middleware)，包括：

- `summarizationMiddleware`：在对话历史过长时进行压缩
- `humanInTheLoopMiddleware`：对敏感的工具调用要求人工批准
- `piiRedactionMiddleware`：在发送给模型之前编辑敏感信息

```ts
import {
  createAgent,
  summarizationMiddleware,
  humanInTheLoopMiddleware,
  piiRedactionMiddleware,
} from "langchain";

const agent = createAgent({
  model: "claude-sonnet-4-5-20250929",
  tools: [readEmail, sendEmail],
  middleware: [
    piiRedactionMiddleware({ patterns: ["email", "phone", "ssn"] }),
    summarizationMiddleware({
      model: "claude-sonnet-4-5-20250929",
      trigger: { tokens: 500 },
    }),
    humanInTheLoopMiddleware({
      interruptOn: {
        sendEmail: {
          allowedDecisions: ["approve", "edit", "reject"],
        },
      },
    }),
  ],
});
```

#### 自定义中间件

你也可以构建自定义中间件以满足特定需求。

通过使用 `createMiddleware` 函数实现以下任意钩子来构建自定义中间件：

| 钩子              | 何时运行             | 用例                               |
|-------------------|--------------------------|-----------------------------------------|
| `beforeAgent`     | 在调用智能体之前 | 加载记忆，验证输入             |
| `beforeModel`     | 在每次 LLM 调用之前     | 更新提示，修剪消息           |
| `wrapModelCall`   | 围绕每次 LLM 调用     | 拦截和修改请求/响应 |
| `wrapToolCall`    | 围绕每次工具调用    | 拦截和修改工具执行     |
| `afterModel`      | 在每次 LLM 响应之后  | 验证输出，应用防护栏       |
| `afterAgent`      | 在智能体完成后    | 保存结果，清理                   |


<div style={{ display: "flex", justifyContent: "center" }}>
  <img
    src="/oss/images/middleware_final.png"
    alt="中间件流程图"
    className="rounded-lg"
  />
</div>


自定义中间件示例：

```ts
import { createMiddleware } from "langchain";

const contextSchema = z.object({
  userExpertise: z.enum(["beginner", "expert"]).default("beginner"),
})

const expertiseBasedToolMiddleware = createMiddleware({
  wrapModelCall: async (request, handler) => {
    const userLevel = request.runtime.context.userExpertise;
    if (userLevel === "expert") {
      const tools = [advancedSearch, dataAnalysis];
      return handler(
        request.replace("openai:gpt-5", tools)
      );
    }
    const tools = [simpleSearch, basicCalculator];
    return handler(
      request.replace("openai:gpt-5-nano", tools)
    );
  },
});

const agent = createAgent({
  model: "claude-sonnet-4-5-20250929",
  tools: [simpleSearch, advancedSearch, basicCalculator, dataAnalysis],
  middleware: [expertiseBasedToolMiddleware],
  contextSchema,
});
```

更多信息，请参阅 [完整的中间件指南](/oss/langchain/middleware)。

### 基于 LangGraph 构建

因为 `createAgent` 基于 LangGraph 构建，所以你自动获得对长期运行和可靠智能体的内置支持，包括：

<CardGroup cols={2}>
    <Card title="持久化" icon="database">
        通过内置检查点，对话自动跨会话持久化
    </Card>
    <Card title="流式传输" icon="water">
        实时流式传输令牌、工具调用和推理轨迹
    </Card>
    <Card title="人在回路" icon="hand">
        在敏感操作前暂停智能体执行以等待人工批准
    </Card>
    <Card title="时间旅行" icon="clock-rotate-left">
        将对话回退到任意点，并探索替代路径和提示
    </Card>
</CardGroup>

你无需学习 LangGraph 即可使用这些功能——它们开箱即用。

### 结构化输出

`createAgent` 改进了结构化输出生成：

- **主循环集成**：结构化输出现在在主循环中生成，而无需额外的 LLM 调用
- **结构化输出策略**：模型可以在调用工具和使用提供商端结构化输出生成之间进行选择
- **成本降低**：消除了额外 LLM 调用带来的额外费用

```ts
import { createAgent } from "langchain";
import * as z from "zod";

const weatherSchema = z.object({
  temperature: z.number(),
  condition: z.string(),
});

const agent = createAgent({
  model: "gpt-4o-mini",
  tools: [getWeather],
  responseFormat: weatherSchema,
});

const result = await agent.invoke({
  messages: [
    { role: "user", content: "What is the weather in Tokyo?" },
  ],
});

console.log(result.structuredResponse);
```

**错误处理**：通过 `ToolStrategy` 的 `handleErrors` 参数控制错误处理：
- **解析错误**：模型生成的数据与所需结构不匹配
- **多个工具调用**：模型为结构化输出模式生成 2 个或更多工具调用

---

## 标准内容块

<Note>
    大多数包已发布 1.0 版本。目前只有以下包支持新的内容块：

    - `langchain`
    - `@langchain/core`
    - `@langchain/anthropic`
    - `@langchain/openai`

    计划未来更广泛地支持内容块。
</Note>

### 优势

- **提供商无关**：无论使用哪个提供商，都可以使用相同的 API 访问推理轨迹、引用、内置工具（网络搜索、代码解释器等）以及其他功能
- **类型安全**：所有内容块类型都有完整的类型提示
- **向后兼容**：标准内容可以 [延迟加载](/oss/langchain/messages#standard-content-blocks)，因此没有相关的破坏性变更

更多信息，请参阅我们的 [内容块指南](/oss/langchain/messages#message-content)

---

## 简化的包

LangChain v1 简化了 `langchain` 包的命名空间，专注于智能体的核心构建模块。该包仅暴露最有用和最相关的功能：

为了方便起见，其中大部分功能都是从 `@langchain/core` 重新导出的，这为你提供了一个专注于构建智能体的 API 表面。

### `@langchain/classic`

遗留功能已移至 [`@langchain/classic`](https://www.npmjs.com/package/@langchain/classic)，以保持核心包的轻量和专注。

#### `@langchain/classic` 包含什么

- 遗留链和链实现
- 检索器
- 索引 API
- [`@langchain/community`](https://www.npmjs.com/package/@langchain/community) 导出
- 其他已弃用的功能

如果你使用任何这些功能，请安装 [`@langchain/classic`](https://www.npmjs.com/package/@langchain/classic)：

<CodeGroup>
```bash npm
npm install @langchain/classic
```
```bash pnpm
pnpm install @langchain/classic
```
```bash yarn
yarn add @langchain/classic
```
```bash bun
bun add @langchain/classic
```
</CodeGroup>

然后更新你的导入：

```typescript
import { ... } from "langchain"; // [!code --]
import { ... } from "@langchain/classic"; // [!code ++]

import { ... } from "langchain/chains"; // [!code --]
import { ... } from "@langchain/classic/chains"; // [!code ++]
```

## 报告问题

请在 [GitHub](https://github.com/langchain-ai/langchainjs/issues) 上使用 [`'v1'` 标签](https://github.com/langchain-ai/langchainjs/issues?q=state%3Aopen%20label%3Av1) 报告发现的任何 1.0 版本问题。

## 其他资源

<CardGroup cols={3}>
    <Card title="LangChain 1.0" icon="rocket" href="https://blog.langchain.com/langchain-langchain-1-0-alpha-releases/">
        阅读公告
    </Card>
    <Card title="中间件指南" icon="puzzle-piece" href="https://blog.langchain.com/agent-middleware/">
        深入探讨中间件
    </Card>
    <Card title="智能体文档" icon="book" href="/oss/langchain/agents" arrow>
        完整的智能体文档
    </Card>
    <Card title="消息内容" icon="message" href="/oss/langchain/messages#message-content" arrow>
        新的内容块 API
    </Card>
    <Card title="迁移指南" icon="arrow-right-arrow-left" href="/oss/migrate/langchain-v1" arrow>
        如何迁移到 LangChain v1
    </Card>
    <Card title="GitHub" icon="github" href="https://github.com/langchain-ai/langchainjs">
        报告问题或贡献代码
    </Card>
</CardGroup>

## 另请参阅

- [版本控制](/oss/versioning) – 理解版本号
- [发布策略](/oss/release-policy) – 详细的发布策略
