---
title: 路由器
---
在**路由器**架构中，路由步骤会对输入进行分类，并将其导向专门的[智能体（agent）](/oss/langchain/agents)。当您拥有不同的**垂直领域**（即各自需要专属智能体的独立知识领域）时，这非常有用。

```mermaid
graph LR
    A([Query]) --> B[Router]
    B --> C[Agent A]
    B --> D[Agent B]
    B --> E[Agent C]
    C --> F[Synthesize]
    D --> F
    E --> F
    F --> G([Combined answer])
```

## 关键特性

*   路由器对查询进行分解
*   零个或多个专门的智能体被并行调用
*   结果被合成为一个连贯的响应

## 何时使用

当您拥有不同的垂直领域（即各自需要专属智能体的独立知识领域）、需要并行查询多个来源，并希望将结果合成为一个组合响应时，请使用路由器模式。

## 基本实现

路由器对查询进行分类并将其导向适当的智能体。使用 [`Command`](/oss/langgraph/graph-api#command) 进行单智能体路由，或使用 [`Send`](/oss/langgraph/graph-api#send) 进行向多个智能体的并行扇出。

<Tabs>
<Tab title="单智能体">

使用 `Command` 路由到单个专门的智能体：

:::python
```python
from langgraph.types import Command

def classify_query(query: str) -> str:
    """使用 LLM 对查询进行分类并确定合适的智能体。"""
    # 分类逻辑在此处
    ...

def route_query(state: State) -> Command:
    """根据查询分类路由到适当的智能体。"""
    active_agent = classify_query(state["query"])

    # 路由到选定的智能体
    return Command(goto=active_agent)
```
:::
:::js
```typescript
import { z } from "zod";
import { Command } from "@langchain/langgraph";

const ClassificationResult = z.object({
  query: z.string(),
  agent: z.string(),
});

function classifyQuery(query: string): z.infer<typeof ClassificationResult> {
  // 使用 LLM 对查询进行分类并确定合适的智能体
  // 分类逻辑在此处
  ...
}

function routeQuery(state: z.infer<typeof ClassificationResult>) {
  const classification = classifyQuery(state.query);

  // 路由到选定的智能体
  return new Command({ goto: classification.agent });
}
```
:::

</Tab>
<Tab title="多智能体（并行）">

使用 `Send` 并行扇出到多个专门的智能体：

:::python
```python
from typing import TypedDict
from langgraph.types import Send

class ClassificationResult(TypedDict):
    query: str
    agent: str

def classify_query(query: str) -> list[ClassificationResult]:
    """使用 LLM 对查询进行分类并确定要调用哪些智能体。"""
    # 分类逻辑在此处
    ...

def route_query(state: State):
    """根据查询分类路由到相关的智能体。"""
    classifications = classify_query(state["query"])

    # 并行扇出到选定的智能体
    return [
        Send(c["agent"], {"query": c["query"]})
        for c in classifications
    ]
```
:::
:::js
```typescript
import { z } from "zod";
import { Command } from "@langchain/langgraph";

const ClassificationResult = z.object({
  query: z.string(),
  agent: z.string(),
});

function classifyQuery(query: string): z.infer<typeof ClassificationResult>[] {
  // 使用 LLM 对查询进行分类并确定合适的智能体
  // 分类逻辑在此处
  ...
}

function routeQuery(state: typeof State.State) {
  const classifications = classifyQuery(state.query);

  // 并行扇出到选定的智能体
  return classifications.map(
    (c) => new Send(c.agent, { query: c.query })
  );
}
```
:::

</Tab>
</Tabs>

有关完整实现，请参阅下面的教程。

<Card title="教程：构建具备路由功能的多源知识库" icon="book" href="/oss/langchain/multi-agent/router-knowledge-base">
构建一个路由器，并行查询 GitHub、Notion 和 Slack，然后将结果综合成一个连贯的答案。涵盖状态定义、专用智能体、使用 `Send` 进行并行执行以及结果综合。
</Card>

## 无状态 vs. 有状态

两种方法：
* [**无状态路由器**](#stateless) 独立处理每个请求
* [**有状态路由器**](#stateful) 在多个请求间维护对话历史

## 无状态

每个请求被独立路由——调用之间没有记忆。对于多轮对话，请参阅[有状态路由器](#stateful)。

<Tip>
**路由器 vs. 子智能体**：两种模式都可以将工作分派给多个智能体，但它们在路由决策的制定方式上有所不同：

- **路由器**：一个专用的路由步骤（通常是单个 LLM 调用或基于规则的逻辑），它对输入进行分类并分派给智能体。路由器本身通常不维护对话历史或执行多轮编排——它是一个预处理步骤。
- **子智能体**：一个主监督智能体在持续对话过程中动态决定调用哪些[子智能体](/oss/langchain/multi-agent/subagents)。主智能体维护上下文，可以在多轮对话中调用多个子智能体，并编排复杂的多步骤工作流。

当你有清晰的输入类别并且希望进行确定性或轻量级分类时，使用**路由器**。当你需要灵活、具备对话感知能力的编排，并且希望 LLM 能根据不断变化的上下文决定下一步做什么时，使用**监督智能体**。
</Tip>

## 有状态

对于多轮对话，你需要在多次调用之间维护上下文。

### 工具包装器

最简单的方法：将无状态路由器包装成一个对话智能体可以调用的工具。对话智能体处理记忆和上下文；路由器保持无状态。这避免了在多个并行智能体之间管理对话历史的复杂性。

:::python
```python
@tool
def search_docs(query: str) -> str:
    """Search across multiple documentation sources."""
    result = workflow.invoke({"query": query})  # [!code highlight]
    return result["final_answer"]

# Conversational agent uses the router as a tool
conversational_agent = create_agent(
    model,
    tools=[search_docs],
    prompt="You are a helpful assistant. Use search_docs to answer questions."
)
```
:::
:::js
```typescript
const searchDocs = tool(
  async ({ query }) => {
    const result = await workflow.invoke({ query }); // [!code highlight]
    return result.finalAnswer;
  },
  {
    name: "search_docs",
    description: "Search across multiple documentation sources",
    schema: z.object({
      query: z.string().describe("The search query"),
    }),
  }
);

// Conversational agent uses the router as a tool
const conversationalAgent = createAgent({
  model,
  tools: [searchDocs],
  systemPrompt: "You are a helpful assistant. Use search_docs to answer questions.",
});
```
:::

### 完全持久化

如果你需要路由器本身维护状态，请使用[持久化](/oss/langchain/short-term-memory)来存储消息历史。当路由到某个智能体时，从状态中获取先前的消息，并有选择地将它们包含在智能体的上下文中——这是[上下文工程](/oss/langchain/context-engineering)的一个杠杆。

<Warning>
**有状态路由器需要自定义历史管理。** 如果路由器在多轮对话中在不同智能体之间切换，当智能体具有不同的语气或提示时，最终用户可能会感觉对话不流畅。使用并行调用时，你需要在路由器级别维护历史记录（输入和综合输出），并在路由逻辑中利用此历史记录。请考虑使用[交接模式](/oss/langchain/multi-agent/handoffs)或[子智能体模式](/oss/langchain/multi-agent/subagents)替代——这两种模式都为多轮对话提供了更清晰的语义。
</Warning>
