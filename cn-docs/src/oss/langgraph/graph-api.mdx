---
title: Graph API 概览
sidebarTitle: Graph API
---
## 图

LangGraph 的核心是将智能体（agent）工作流建模为图。您可以使用三个关键组件来定义智能体的行为：

1. [`State`](#state)：一个共享的数据结构，代表应用程序的当前快照。它可以是任何数据类型，但通常使用共享状态模式（schema）来定义。

2. [`Nodes`](#nodes)：编码智能体逻辑的函数。它们接收当前状态作为输入，执行一些计算或产生副作用，并返回更新后的状态。

3. [`Edges`](#edges)：根据当前状态决定接下来执行哪个 `Node` 的函数。它们可以是条件分支或固定转换。

通过组合 `Nodes` 和 `Edges`，您可以创建随时间推移而状态演变的复杂、循环工作流。然而，真正的威力来自于 LangGraph 如何管理该状态。

需要强调的是：`Nodes` 和 `Edges` 只不过是函数——它们可以包含一个 LLM 或者仅仅是普通的代码。

简而言之：_节点执行工作，边决定下一步做什么_。

LangGraph 底层的图算法使用[消息传递](https://en.wikipedia.org/wiki/Message_passing)来定义一个通用程序。当一个节点完成其操作时，它会沿着一条或多条边向其他节点发送消息。这些接收节点然后执行其函数，将结果消息传递给下一组节点，过程持续进行。受谷歌的 [Pregel](https://research.google/pubs/pregel-a-system-for-large-scale-graph-processing/) 系统启发，该程序以离散的“超级步（super-step）”进行。

一个超级步可以被视为对图节点的一次迭代。并行运行的节点属于同一个超级步，而顺序运行的节点则属于不同的超级步。在图执行开始时，所有节点都处于 `inactive` 状态。当一个节点在其任何传入边（或“通道”）上接收到新消息（状态）时，它就变为 `active`。然后，活动节点运行其函数并响应更新。在每个超级步结束时，没有传入消息的节点通过将自身标记为 `inactive` 来投票 `halt`。当所有节点都处于 `inactive` 状态且没有消息在传输中时，图执行终止。

### StateGraph

@[`StateGraph`] 类是主要使用的图类。它由用户定义的 `State` 对象参数化。

### 编译您的图

要构建您的图，您首先定义[状态](#state)，然后添加[节点](#nodes)和[边](#edges)，最后编译它。编译您的图到底是什么，为什么需要它？

编译是一个相当简单的步骤。它对图的结构进行一些基本检查（例如，没有孤立节点等）。这也是您可以指定运行时参数的地方，比如[检查点（checkpointers）](/oss/langgraph/persistence)和断点。您只需调用 `.compile` 方法来编译您的图：

:::python

```python
graph = graph_builder.compile(...)
```

:::

:::js

```typescript
const graph = new StateGraph(StateAnnotation)
  .addNode("nodeA", nodeA)
  .addEdge(START, "nodeA")
  .addEdge("nodeA", END)
  .compile();
```

:::

<Warning>
    在使用图之前，您**必须**编译它。
</Warning>

## 状态

:::python
定义图时，您要做的第一件事就是定义图的 `State`。`State` 由[图的模式（schema）](#schema)以及指定如何将更新应用到状态的[`reducer` 函数](#reducers)组成。`State` 的模式将是图中所有 `Nodes` 和 `Edges` 的输入模式，可以是 `TypedDict` 或 `Pydantic` 模型。所有 `Nodes` 都会发出对 `State` 的更新，然后使用指定的 `reducer` 函数来应用这些更新。
:::

:::js
定义图时首先要定义图的 `State`。`State` 包含图的[模式（schema）](#schema)以及指定如何对状态应用更新的 [`reducer` 函数](#reducers)。`State` 的模式将是图中所有 `Nodes` 和 `Edges` 的输入模式，可以是 Zod 模式或使用 `Annotation.Root` 构建的模式。所有 `Nodes` 都会向 `State` 发出更新，然后使用指定的 `reducer` 函数应用这些更新。
:::

### 模式

:::python
指定图模式的主要文档化方法是使用 [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict)。如果希望在状态中提供默认值，请使用 [`dataclass`](https://docs.python.org/3/library/dataclasses.html)。如果需要递归数据验证，我们也支持使用 Pydantic [`BaseModel`](/oss/langgraph/use-graph-api#use-pydantic-models-for-graph-state) 作为图状态（但请注意，Pydantic 的性能不如 `TypedDict` 或 `dataclass`）。

默认情况下，图将具有相同的输入和输出模式。如果想改变这一点，也可以直接指定显式的输入和输出模式。这在有很多键，并且其中一些明确用于输入而另一些用于输出时非常有用。更多信息请参阅[指南](/oss/langgraph/use-graph-api#define-input-and-output-schemas)。
:::

:::js
指定图模式的主要文档化方法是使用 Zod 模式。但是，我们也支持使用 `Annotation` API 来定义图的模式。

默认情况下，图将具有相同的输入和输出模式。如果想改变这一点，也可以直接指定显式的输入和输出模式。这在有很多键，并且其中一些明确用于输入而另一些用于输出时非常有用。
:::

#### 多个模式

通常，所有图节点都使用单一模式进行通信。这意味着它们将读取和写入相同的状态通道。但是，有些情况下我们需要对此进行更多控制：

- 内部节点可以传递图中输入/输出不需要的信息。
- 我们可能还希望为图使用不同的输入/输出模式。例如，输出可能只包含一个相关的输出键。

可以让节点写入图内部的私有状态通道，用于内部节点通信。我们可以简单地定义一个私有模式 `PrivateState`。

也可以为图定义显式的输入和输出模式。在这些情况下，我们定义一个“内部”模式，其中包含与图操作相关的*所有*键。但是，我们还定义 `input` 和 `output` 模式，它们是“内部”模式的子集，用于约束图的输入和输出。更多细节请参阅[本指南](/oss/langgraph/graph-api#define-input-and-output-schemas)。

让我们看一个例子：

:::python

```python
class InputState(TypedDict):
    user_input: str

class OutputState(TypedDict):
    graph_output: str

class OverallState(TypedDict):
    foo: str
    user_input: str
    graph_output: str

class PrivateState(TypedDict):
    bar: str

def node_1(state: InputState) -> OverallState:
    # 写入 OverallState
    return {"foo": state["user_input"] + " name"}

def node_2(state: OverallState) -> PrivateState:
    # 从 OverallState 读取，写入 PrivateState
    return {"bar": state["foo"] + " is"}

def node_3(state: PrivateState) -> OutputState:
    # 从 PrivateState 读取，写入 OutputState
    return {"graph_output": state["bar"] + " Lance"}

builder = StateGraph(OverallState,input_schema=InputState,output_schema=OutputState)
builder.add_node("node_1", node_1)
builder.add_node("node_2", node_2)
builder.add_node("node_3", node_3)
builder.add_edge(START, "node_1")
builder.add_edge("node_1", "node_2")
builder.add_edge("node_2", "node_3")
builder.add_edge("node_3", END)
```

graph = builder.compile()
graph.invoke({"user_input":"My"})
# {'graph_output': 'My name is Lance'}
```

:::

:::js

```typescript
const InputState = z.object({
  userInput: z.string(),
});

const OutputState = z.object({
  graphOutput: z.string(),
});

const OverallState = z.object({
  foo: z.string(),
  userInput: z.string(),
  graphOutput: z.string(),
});

const PrivateState = z.object({
  bar: z.string(),
});

const graph = new StateGraph({
  state: OverallState,
  input: InputState,
  output: OutputState,
})
  .addNode("node1", (state) => {
    // 写入 OverallState
    return { foo: state.userInput + " name" };
  })
  .addNode("node2", (state) => {
    // 从 OverallState 读取，写入 PrivateState
    return { bar: state.foo + " is" };
  })
  .addNode(
    "node3",
    (state) => {
      // 从 PrivateState 读取，写入 OutputState
      return { graphOutput: state.bar + " Lance" };
    },
    { input: PrivateState }
  )
  .addEdge(START, "node1")
  .addEdge("node1", "node2")
  .addEdge("node2", "node3")
  .addEdge("node3", END)
  .compile();

await graph.invoke({ userInput: "My" });
// { graphOutput: 'My name is Lance' }
```

:::

这里有两个微妙而重要的点需要注意：

:::python

1.  我们将 `state: InputState` 作为输入模式传递给 `node_1`。但是，我们写入了 `foo`，这是 `OverallState` 中的一个通道。我们如何能写入一个未包含在输入模式中的状态通道？这是因为一个节点*可以写入图状态中的任何状态通道*。图状态是初始化时定义的状态通道的并集，其中包括 `OverallState` 以及过滤器 `InputState` 和 `OutputState`。

2.  我们使用以下方式初始化图：

    ```python
    StateGraph(
        OverallState,
        input_schema=InputState,
        output_schema=OutputState
    )
    ```

    那么，我们如何在 `node_2` 中写入 `PrivateState`？如果 `StateGraph` 初始化时没有传入此模式，图是如何获得访问该模式的权限的？

    我们可以这样做，是因为只要状态模式定义存在，`_nodes` 也可以声明额外的状态 `channels_`。在这个例子中，`PrivateState` 模式已定义，因此我们可以将 `bar` 作为图中的新状态通道并写入它。
:::

:::js

1.  我们将 `state` 作为输入模式传递给 `node1`。但是，我们写入了 `foo`，这是 `OverallState` 中的一个通道。我们如何能写入一个未包含在输入模式中的状态通道？这是因为一个节点*可以写入图状态中的任何状态通道*。图状态是初始化时定义的状态通道的并集，其中包括 `OverallState` 以及过滤器 `InputState` 和 `OutputState`。

2.  我们使用 `StateGraph({ state: OverallState, input: InputState, output: OutputState })` 初始化图。那么，我们如何在 `node2` 中写入 `PrivateState`？如果 `StateGraph` 初始化时没有传入此模式，图是如何获得访问该模式的权限的？我们可以这样做，是因为只要状态模式定义存在，*节点也可以声明额外的状态通道*。在这个例子中，`PrivateState` 模式已定义，因此我们可以将 `bar` 作为图中的新状态通道并写入它。
:::

### 归约器（Reducers）

归约器是理解节点更新如何应用到 `State` 的关键。`State` 中的每个键都有其独立的归约器函数。如果没有明确指定归约器函数，则假定对该键的所有更新都应覆盖它。有几种不同类型的归约器，从默认类型开始：

#### 默认归约器

这两个示例展示了如何使用默认归约器：

:::python

```python 示例 A
from typing_extensions import TypedDict

class State(TypedDict):
    foo: int
    bar: list[str]
```

:::

:::js

```typescript 示例 A
const State = z.object({
  foo: z.number(),
  bar: z.array(z.string()),
});
```

:::

在这个示例中，没有为任何键指定归约函数。假设图的输入是：

:::python
`{"foo": 1, "bar": ["hi"]}`。然后假设第一个 `Node` 返回 `{"foo": 2}`。这被视为对状态的一次更新。请注意，`Node` 不需要返回完整的 `State` 模式——只需返回一个更新。应用此更新后，`State` 将变为 `{"foo": 2, "bar": ["hi"]}`。如果第二个节点返回 `{"bar": ["bye"]}`，那么 `State` 将变为 `{"foo": 2, "bar": ["bye"]}`
:::

:::js
`{ foo: 1, bar: ["hi"] }`。然后假设第一个 `Node` 返回 `{ foo: 2 }`。这被视为对状态的一次更新。请注意，`Node` 不需要返回完整的 `State` 模式——只需返回一个更新。应用此更新后，`State` 将变为 `{ foo: 2, bar: ["hi"] }`。如果第二个节点返回 `{ bar: ["bye"] }`，那么 `State` 将变为 `{ foo: 2, bar: ["bye"] }`
:::

:::python

```python Example B
from typing import Annotated
from typing_extensions import TypedDict
from operator import add

class State(TypedDict):
    foo: int
    bar: Annotated[list[str], add]
```

在这个示例中，我们使用了 `Annotated` 类型为第二个键（`bar`）指定了一个归约函数（`operator.add`）。请注意，第一个键保持不变。假设图的输入是 `{"foo": 1, "bar": ["hi"]}`。然后假设第一个 `Node` 返回 `{"foo": 2}`。这被视为对状态的一次更新。请注意，`Node` 不需要返回完整的 `State` 模式——只需返回一个更新。应用此更新后，`State` 将变为 `{"foo": 2, "bar": ["hi"]}`。如果第二个节点返回 `{"bar": ["bye"]}`，那么 `State` 将变为 `{"foo": 2, "bar": ["hi", "bye"]}`。请注意，这里 `bar` 键是通过将两个列表相加来更新的。
:::

:::js

```typescript Example B
import * as z from "zod";
import { registry } from "@langchain/langgraph/zod";

const State = z.object({
  foo: z.number(),
  bar: z.array(z.string()).register(registry, {
    reducer: {
      fn: (x, y) => x.concat(y),
    },
    default: () => [] as string[],
  }),
});
```

在这个示例中，我们使用了 [Zod 4 注册表](https://zod.dev/metadata) 为第二个键（`bar`）指定了一个归约函数。请注意，第一个键保持不变。假设图的输入是 `{ foo: 1, bar: ["hi"] }`。然后假设第一个 `Node` 返回 `{ foo: 2 }`。这被视为对状态的一次更新。请注意，`Node` 不需要返回完整的 `State` 模式——只需返回一个更新。应用此更新后，`State` 将变为 `{ foo: 2, bar: ["hi"] }`。如果第二个节点返回 `{ bar: ["bye"] }`，那么 `State` 将变为 `{ foo: 2, bar: ["hi", "bye"] }`。请注意，这里 `bar` 键是通过将两个数组相加来更新的。
:::

:::python
#### 覆盖
<Tip>
在某些情况下，您可能希望绕过归约器并直接覆盖状态值。LangGraph 为此提供了 [`Overwrite`](https://reference.langchain.com/python/langgraph/types/) 类型。[在此处了解如何使用 `Overwrite`](/oss/langgraph/use-graph-api#bypass-reducers-with-overwrite)。
</Tip>
:::

### 在图状态中使用消息

#### 为什么使用消息？

大多数现代 LLM 提供商都有一个聊天模型接口，它接受一个消息列表作为输入。LangChain 的[聊天模型接口](/oss/langchain/models)尤其接受一个消息对象列表作为输入。这些消息有多种形式，例如 @[`HumanMessage`]（用户输入）或 @[`AIMessage`]（LLM 响应）。

要了解更多关于消息对象的信息，请参阅[消息概念指南](/oss/langchain/messages)。

#### 在您的图中使用消息

在许多情况下，将先前的对话历史记录作为消息列表存储在您的图状态中会很有帮助。为此，我们可以向图状态添加一个键（通道），用于存储 `Message` 对象列表，并使用一个归约函数对其进行注解（参见下面示例中的 `messages` 键）。归约函数至关重要，它告诉图如何随着每次状态更新（例如，当节点发送更新时）来更新状态中的 `Message` 对象列表。如果您不指定归约函数，每次状态更新都会用最近提供的值覆盖消息列表。如果您只想将消息追加到现有列表中，可以使用 `operator.add` 作为归约函数。

然而，您可能还希望手动更新图状态中的消息（例如，人机协同）。如果您使用 `operator.add`，您发送到图的手动状态更新将被追加到现有的消息列表中，而不是更新现有消息。为了避免这种情况，您需要一个能够跟踪消息 ID 并在更新时覆盖现有消息的归约函数。为了实现这一点，您可以使用预构建的 @[`add_messages`] 函数。对于全新的消息，它只会简单地追加到现有列表中，但它也能正确处理现有消息的更新。

#### 序列化

除了跟踪消息 ID 之外，每当在 `messages` 通道上接收到状态更新时，@[`add_messages`] 函数还会尝试将消息反序列化为 LangChain `Message` 对象。

有关 LangChain 序列化/反序列化的更多信息，请参见[此处](https://python.langchain.com/docs/how_to/serialization/)。这允许以以下格式发送图输入 / 状态更新：

```python
# 这是支持的
{"messages": [HumanMessage(content="message")]}

# 这也是支持的
{"messages": [{"type": "human", "content": "message"}]}
```

由于在使用 @[`add_messages`] 时，状态更新总是被反序列化为 LangChain `Messages`，因此您应该使用点表示法来访问消息属性，例如 `state["messages"][-1].content`。

下面是一个使用 @[`add_messages`] 作为其归约函数的图示例。

```python
from langchain.messages import AnyMessage
from langgraph.graph.message import add_messages
from typing import Annotated
from typing_extensions import TypedDict

class GraphState(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]
```

:::js
除了跟踪消息ID，`MessagesZodMeta`还会尝试在`messages`通道上接收到状态更新时，将消息反序列化为LangChain的`Message`对象。这允许以以下格式发送图输入/状态更新：

```typescript
// 这是支持的
{
  messages: [new HumanMessage("message")];
}

// 这也是支持的
{
  messages: [{ role: "human", content: "message" }];
}
```

由于在使用`MessagesZodMeta`时，状态更新总是被反序列化为LangChain的`Messages`，你应该使用点符号来访问消息属性，例如`state.messages[state.messages.length - 1].content`。下面是一个使用`MessagesZodMeta`的图示例：

```typescript
import { StateGraph, MessagesZodMeta } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const MessagesZodState = z.object({
  messages: z
    .array(z.custom<BaseMessage>())
    .register(registry, MessagesZodMeta),
});

const graph = new StateGraph(MessagesZodState)
  ...
```

`MessagesZodState`被定义为具有单个`messages`键，它是一个@[`BaseMessage`]对象列表，并使用适当的归约器。通常，除了消息之外还有更多的状态需要跟踪，所以我们看到人们扩展这个状态并添加更多字段，例如：

```typescript
const State = z.object({
  messages: z
    .array(z.custom<BaseMessage>())
    .register(registry, MessagesZodMeta),
  documents: z.array(z.string()),
});
```

:::

:::python

#### MessagesState

由于在状态中拥有一个消息列表非常常见，因此存在一个名为`MessagesState`的预构建状态，它使得使用消息变得容易。`MessagesState`被定义为具有单个`messages`键，它是一个`AnyMessage`对象列表，并使用@[`add_messages`]归约器。通常，除了消息之外还有更多的状态需要跟踪，所以我们看到人们子类化这个状态并添加更多字段，例如：

```python
from langgraph.graph import MessagesState

class State(MessagesState):
    documents: list[str]
```

:::

## 节点

:::python

在LangGraph中，节点是接受以下参数的Python函数（同步或异步）：

1. `state` – 图的[状态](#state)
2. `config` – 一个@[`RunnableConfig`]对象，包含配置信息，如`thread_id`，以及追踪信息，如`tags`
3. `runtime` – 一个`Runtime`对象，包含[运行时`context`](#runtime-context)和其他信息，如`store`和`stream_writer`

与`NetworkX`类似，你可以使用@[`add_node`]方法将这些节点添加到图中：

```python
from dataclasses import dataclass
from typing_extensions import TypedDict

from langchain_core.runnables import RunnableConfig
from langgraph.graph import StateGraph
from langgraph.runtime import Runtime

class State(TypedDict):
    input: str
    results: str

@dataclass
class Context:
    user_id: str

builder = StateGraph(State)

def plain_node(state: State):
    return state

def node_with_runtime(state: State, runtime: Runtime[Context]):
    print("In node: ", runtime.context.user_id)
    return {"results": f"Hello, {state['input']}!"}

def node_with_config(state: State, config: RunnableConfig):
    print("In node with thread_id: ", config["configurable"]["thread_id"])
    return {"results": f"Hello, {state['input']}!"}


builder.add_node("plain_node", plain_node)
builder.add_node("node_with_runtime", node_with_runtime)
builder.add_node("node_with_config", node_with_config)
...
```

:::

:::js

在LangGraph中，节点通常是接受以下参数的函数（同步或异步）：

1. `state` – 图的[状态](#state)
2. `config` – 一个@[`RunnableConfig`]对象，包含配置信息，如`thread_id`，以及追踪信息，如`tags`

你可以使用`addNode`方法将节点添加到图中。

```typescript
import { StateGraph } from "@langchain/langgraph";
import { RunnableConfig } from "@langchain/core/runnables";
import * as z from "zod";

const State = z.object({
  input: z.string(),
  results: z.string(),
});

const builder = new StateGraph(State);
  .addNode("myNode", (state, config) => {
    console.log("In node: ", config?.configurable?.user_id);
    return { results: `Hello, ${state.input}!` };
  })
  addNode("otherNode", (state) => {
    return state;
  })
  ...
```

:::

在幕后，函数会被转换为 [`RunnableLambda`](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableLambda.html)，这为你的函数添加了批处理和异步支持，以及原生的追踪和调试功能。

如果你向图中添加一个节点但没有指定名称，它将被赋予一个默认名称，等同于函数名。

:::python

```python
builder.add_node(my_node)
# 然后你可以通过引用 `"my_node"` 来创建指向/来自此节点的边
```

:::

:::js

```typescript
builder.addNode(myNode);
// 然后你可以通过引用 `"myNode"` 来创建指向/来自此节点的边
```

:::

### `START` 节点

@[`START`] 节点是一个特殊的节点，代表将用户输入发送到图的节点。引用此节点的主要目的是确定哪些节点应该首先被调用。

:::python

```python
from langgraph.graph import START

graph.add_edge(START, "node_a")
```

:::

:::js

```typescript
import { START } from "@langchain/langgraph";

graph.addEdge(START, "nodeA");
```

:::

### `END` 节点

`END` 节点是一个特殊的节点，代表一个终端节点。当你想要表示哪些边在完成后没有后续动作时，会引用此节点。

:::python

```python
from langgraph.graph import END

graph.add_edge("node_a", END)
```

:::

:::js

```typescript
import { END } from "@langchain/langgraph";

graph.addEdge("nodeA", END);
```

:::

### 节点缓存

:::python
LangGraph 支持基于节点输入的任务/节点缓存。要使用缓存：

- 在编译图（或指定入口点）时指定一个缓存
- 为节点指定缓存策略。每个缓存策略支持：
  - `key_func`，用于根据节点输入生成缓存键，默认为使用 pickle 对输入进行 `hash`。
  - `ttl`，缓存的生存时间（秒）。如果未指定，缓存将永不过期。

例如：

```python
import time
from typing_extensions import TypedDict
from langgraph.graph import StateGraph
from langgraph.cache.memory import InMemoryCache
from langgraph.types import CachePolicy


class State(TypedDict):
    x: int
    result: int


builder = StateGraph(State)


def expensive_node(state: State) -> dict[str, int]:
    # 昂贵的计算
    time.sleep(2)
    return {"result": state["x"] * 2}


builder.add_node("expensive_node", expensive_node, cache_policy=CachePolicy(ttl=3))
builder.set_entry_point("expensive_node")
builder.set_finish_point("expensive_node")

graph = builder.compile(cache=InMemoryCache())

print(graph.invoke({"x": 5}, stream_mode='updates'))    # [!code highlight]
# [{'expensive_node': {'result': 10}}]
print(graph.invoke({"x": 5}, stream_mode='updates'))    # [!code highlight]
# [{'expensive_node': {'result': 10}, '__metadata__': {'cached': True}}]
```

1.  第一次运行需要两秒钟（由于模拟了昂贵的计算）。
2.  第二次运行利用了缓存并快速返回。
:::

:::js
LangGraph 支持基于节点输入的任务/节点缓存。要使用缓存：

- 在编译图（或指定入口点）时指定一个缓存
- 为节点指定缓存策略。每个缓存策略支持：
  - `keyFunc`，用于根据节点输入生成缓存键。
  - `ttl`，缓存的生存时间（秒）。如果未指定，缓存将永不过期。

```typescript
import { StateGraph, MessagesZodMeta } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";
import { InMemoryCache } from "@langchain/langgraph-checkpoint";

const MessagesZodState = z.object({
  messages: z
    .array(z.custom<BaseMessage>())
    .register(registry, MessagesZodMeta),
});

const graph = new StateGraph(MessagesZodState)
  .addNode(
    "expensive_node",
    async () => {
      // 模拟一个耗时操作
      await new Promise((resolve) => setTimeout(resolve, 3000));
      return { result: 10 };
    },
    { cachePolicy: { ttl: 3 } }
  )
  .addEdge(START, "expensive_node")
  .compile({ cache: new InMemoryCache() });

await graph.invoke({ x: 5 }, { streamMode: "updates" });   // [!code highlight]
// [{"expensive_node": {"result": 10}}]
await graph.invoke({ x: 5 }, { streamMode: "updates" });   // [!code highlight]
// [{"expensive_node": {"result": 10}, "__metadata__": {"cached": true}}]
```

:::

## 边（Edges）

边定义了逻辑如何路由以及图如何决定停止。这是你的智能体（agent）如何工作以及不同节点之间如何通信的重要组成部分。有几种关键类型的边：

- 普通边（Normal Edges）：直接从节点 A 到节点 B。
- 条件边（Conditional Edges）：调用一个函数来决定接下来去哪个节点。
- 入口点（Entry Point）：当用户输入到达时首先调用哪个节点。
- 条件入口点（Conditional Entry Point）：调用一个函数来决定当用户输入到达时首先调用哪个节点。

一个节点可以有多条出边。如果一个节点有多条出边，那么**所有**这些目标节点将作为下一个超步（superstep）的一部分并行执行。

### 普通边

:::python
如果你**总是**想从节点 A 到节点 B，可以直接使用 @[`add_edge`] 方法。

```python
graph.add_edge("node_a", "node_b")
```

:::

:::js
如果你**总是**想从节点 A 到节点 B，可以直接使用 @[`addEdge`] 方法。

```typescript
graph.addEdge("nodeA", "nodeB");
```

:::

### 条件边

:::python
如果你想**有条件地**路由到一条或多条边（或选择性地终止），可以使用 @[`add_conditional_edges`] 方法。该方法接受一个节点名称和一个在该节点执行后调用的"路由函数"：

```python
graph.add_conditional_edges("node_a", routing_function)
```

与节点类似，`routing_function` 接受图的当前 `state` 并返回一个值。

默认情况下，`routing_function` 的返回值被用作下一个要发送状态的节点（或节点列表）的名称。所有这些节点将作为下一个超步的一部分并行运行。

你可以选择提供一个字典，将 `routing_function` 的输出映射到下一个节点的名称。

```python
graph.add_conditional_edges("node_a", routing_function, {True: "node_b", False: "node_c"})
```

:::

:::js
如果你想**有条件地**路由到一条或多条边（或选择性地终止），可以使用 @[`addConditionalEdges`] 方法。该方法接受一个节点名称和一个在该节点执行后调用的"路由函数"：

```typescript
graph.addConditionalEdges("nodeA", routingFunction);
```

与节点类似，`routingFunction` 接受图的当前 `state` 并返回一个值。

默认情况下，`routingFunction` 的返回值被用作下一个要发送状态的节点（或节点列表）的名称。所有这些节点将作为下一个超步的一部分并行运行。

你可以选择提供一个对象，将 `routingFunction` 的输出映射到下一个节点的名称。

```typescript
graph.addConditionalEdges("nodeA", routingFunction, {
  true: "nodeB",
  false: "nodeC",
});
```

:::

<Tip>

如果你想在单个函数中结合状态更新和路由，请使用 [`Command`](#command) 而不是条件边。

</Tip>

### 入口点

入口点是图启动时首先运行的节点。您可以使用虚拟 @[`START`][START] 节点到第一个执行节点的 @[`add_edge`] 方法来指定图的入口位置。

```python
from langgraph.graph import START

graph.add_edge(START, "node_a")
```

入口点是图启动时首先运行的节点。您可以使用虚拟 @[`START`] 节点到第一个执行节点的 @[`addEdge`] 方法来指定图的入口位置。

```typescript
import { START } from "@langchain/langgraph";

graph.addEdge(START, "nodeA");
```

### 条件入口点

条件入口点允许您根据自定义逻辑从不同的节点开始。您可以使用虚拟 @[`START`] 节点的 @[`add_conditional_edges`] 方法来实现这一点。

```python
from langgraph.graph import START

graph.add_conditional_edges(START, routing_function)
```

您可以选择提供一个字典，将 `routing_function` 的输出映射到下一个节点的名称。

```python
graph.add_conditional_edges(START, routing_function, {True: "node_b", False: "node_c"})
```

条件入口点允许您根据自定义逻辑从不同的节点开始。您可以使用虚拟 @[`START`] 节点的 @[`addConditionalEdges`] 方法来实现这一点。

```typescript
import { START } from "@langchain/langgraph";

graph.addConditionalEdges(START, routingFunction);
```

您可以选择提供一个对象，将 `routingFunction` 的输出映射到下一个节点的名称。

```typescript
graph.addConditionalEdges(START, routingFunction, {
  true: "nodeB",
  false: "nodeC",
});
```

## `Send`

默认情况下，`Nodes` 和 `Edges` 是预先定义的，并在相同的共享状态上操作。然而，有些情况下，确切的边是预先未知的，和/或您可能希望同时存在不同版本的 `State`。一个常见的例子是 [map-reduce](/oss/langgraph/graph-api#map-reduce-and-the-send-api) 设计模式。在这种设计模式中，第一个节点可能生成一个对象列表，而您可能希望将其他节点应用于所有这些对象。对象的数量可能预先未知（意味着边的数量可能未知），并且下游 `Node` 的输入 `State` 应该不同（每个生成的对象对应一个）。

为了支持这种设计模式，LangGraph 支持从条件边返回 @[`Send`] 对象。`Send` 接受两个参数：第一个是节点的名称，第二个是传递给该节点的状态。

```python
def continue_to_jokes(state: OverallState):
    return [Send("generate_joke", {"subject": s}) for s in state['subjects']]

graph.add_conditional_edges("node_a", continue_to_jokes)
```

默认情况下，`Nodes` 和 `Edges` 是预先定义的，并在相同的共享状态上操作。然而，有些情况下，确切的边是预先未知的，和/或您可能希望同时存在不同版本的 `State`。一个常见的例子是 map-reduce 设计模式。在这种设计模式中，第一个节点可能生成一个对象列表，而您可能希望将其他节点应用于所有这些对象。对象的数量可能预先未知（意味着边的数量可能未知），并且下游 `Node` 的输入 `State` 应该不同（每个生成的对象对应一个）。

为了支持这种设计模式，LangGraph 支持从条件边返回 @[`Send`] 对象。`Send` 接受两个参数：第一个是节点的名称，第二个是传递给该节点的状态。

```typescript
import { Send } from "@langchain/langgraph";

graph.addConditionalEdges("nodeA", (state) => {
  return state.subjects.map((subject) => new Send("generateJoke", { subject }));
});
```

## `Command`

:::python
将控制流（边）和状态更新（节点）结合起来会很有用。例如，你可能希望在同一个节点中**同时**执行状态更新**并**决定接下来要转到哪个节点。LangGraph 提供了一种方法，即从节点函数返回一个 @[`Command`] 对象：

```python
def my_node(state: State) -> Command[Literal["my_other_node"]]:
    return Command(
        # state update
        update={"foo": "bar"},
        # control flow
        goto="my_other_node"
    )
```

使用 @[`Command`]，你还可以实现动态控制流行为（与[条件边](#conditional-edges)相同）：

```python
def my_node(state: State) -> Command[Literal["my_other_node"]]:
    if state["foo"] == "bar":
        return Command(update={"foo": "baz"}, goto="my_other_node")
```

:::

:::js
将控制流（边）和状态更新（节点）结合起来会很有用。例如，你可能希望在同一个节点中**同时**执行状态更新**并**决定接下来要转到哪个节点。LangGraph 提供了一种方法，即从节点函数返回一个 @[`Command`] 对象：

```typescript
import { Command } from "@langchain/langgraph";

graph.addNode("myNode", (state) => {
  return new Command({
    update: { foo: "bar" },
    goto: "myOtherNode",
  });
});
```

使用 @[`Command`]，你还可以实现动态控制流行为（与[条件边](#conditional-edges)相同）：

```typescript
import { Command } from "@langchain/langgraph";

graph.addNode("myNode", (state) => {
  if (state.foo === "bar") {
    return new Command({
      update: { foo: "baz" },
      goto: "myOtherNode",
    });
  }
});
```

在节点函数中使用 @[`Command`] 时，必须在添加节点时指定 `ends` 参数，以说明它可以路由到哪些节点：

```typescript
builder.addNode("myNode", myNode, {
  ends: ["myOtherNode", END],
});
```

:::

<Note>

在节点函数中返回 @[`Command`] 时，必须添加返回类型注解，其中包含节点可以路由到的节点名称列表，例如 `Command[Literal["my_other_node"]]`。这对于图渲染是必需的，并告诉 LangGraph `my_node` 可以导航到 `my_other_node`。

</Note>

查看这个[操作指南](/oss/langgraph/use-graph-api#combine-control-flow-and-state-updates-with-command)，了解如何使用 @[`Command`] 的端到端示例。

### 何时应该使用 Command 而不是条件边？

- 当你需要**同时**更新图状态**并**路由到不同节点时，请使用 @[`Command`]。例如，在实现[多智能体交接](/oss/langchain/multi-agent/handoffs)时，路由到不同的智能体并向该智能体传递一些信息非常重要。
- 使用[条件边](#conditional-edges)可以在不更新状态的情况下有条件地在节点之间路由。

### 导航到父图中的节点

:::python
如果你正在使用[子图](/oss/langgraph/use-subgraphs)，你可能希望从子图内的节点导航到不同的子图（即父图中的不同节点）。为此，你可以在 @[`Command`] 中指定 `graph=Command.PARENT`：

```python
def my_node(state: State) -> Command[Literal["other_subgraph"]]:
    return Command(
        update={"foo": "bar"},
        goto="other_subgraph",  # 其中 `other_subgraph` 是父图中的一个节点
        graph=Command.PARENT
    )
```

<Note>

将 `graph` 设置为 `Command.PARENT` 将导航到最近的父图。

当你从子图节点向父图节点发送更新，且更新的键同时存在于父图和子图的[状态模式](#schema)中时，你**必须**在父图状态中为你正在更新的键定义一个[归约器](#reducers)。请参阅此[示例](/oss/langgraph/use-graph-api#navigate-to-a-node-in-a-parent-graph)。

</Note>

:::

:::js
如果您正在使用[子图（subgraphs）](/oss/langgraph/use-subgraphs)，您可能希望从子图内的一个节点导航到另一个子图（即父图中的不同节点）。为此，您可以在 `Command` 中指定 `graph: Command.PARENT`：

```typescript
import { Command } from "@langchain/langgraph";

graph.addNode("myNode", (state) => {
  return new Command({
    update: { foo: "bar" },
    goto: "otherSubgraph", // 其中 `otherSubgraph` 是父图中的一个节点
    graph: Command.PARENT,
  });
});
```

<Note>

将 `graph` 设置为 `Command.PARENT` 将导航到最近的父图。

当您从子图节点向父图节点发送更新，且更新的键同时存在于父图和子图的[状态模式（state schemas）](#schema)中时，您**必须**在父图状态中为您正在更新的键定义一个[归约器（reducer）](#reducers)。

</Note>

:::

这在实现[多智能体交接（multi-agent handoffs）](/oss/langchain/multi-agent/handoffs)时特别有用。

查看[本指南](/oss/langgraph/use-graph-api#navigate-to-a-node-in-a-parent-graph)了解详情。

### 在工具内部使用

一个常见的用例是从工具内部更新图状态。例如，在客户支持应用程序中，您可能希望在对话开始时根据客户的账号或 ID 查找客户信息。

查看[本指南](/oss/langgraph/use-graph-api#use-inside-tools)了解详情。

### 人机协同（human-in-the-loop）

:::python
@[`Command`] 是人机协同（human-in-the-loop）工作流的重要组成部分：当使用 `interrupt()` 收集用户输入时，@[`Command`] 随后用于提供输入并通过 `Command(resume="User input")` 恢复执行。查看[此概念指南](/oss/langgraph/interrupts)了解更多信息。
:::

:::js
@[`Command`] 是人机协同（human-in-the-loop）工作流的重要组成部分：当使用 `interrupt()` 收集用户输入时，@[`Command`] 随后用于提供输入并通过 `new Command({ resume: "User input" })` 恢复执行。查看[人机协同概念指南](/oss/langgraph/interrupts)了解更多信息。
:::

## 图迁移

LangGraph 可以轻松处理图定义（节点、边和状态）的迁移，即使在使用检查点（checkpointer）跟踪状态时也是如此。

*   对于位于图末尾的线程（即未中断的），您可以更改图的整个拓扑结构（即所有节点和边，删除、添加、重命名等）。
*   对于当前中断的线程，我们支持除重命名/删除节点之外的所有拓扑更改（因为该线程现在可能即将进入一个不再存在的节点）——如果这成为阻碍，请联系我们，我们可以优先解决。
*   对于修改状态，我们在添加和删除键方面具有完全的向后和向前兼容性。
*   重命名的状态键在现有线程中会丢失其保存的状态。
*   类型以不兼容方式更改的状态键，目前可能会在包含更改前状态的线程中引发问题——如果这成为阻碍，请联系我们，我们可以优先解决。

## 运行时上下文（runtime context）

:::python

创建图时，您可以为传递给节点的运行时上下文指定一个 `context_schema`。这对于向节点传递不属于图状态的信息非常有用。例如，您可能希望传递模型名称或数据库连接等依赖项。

:::

:::js
创建图时，您可以为传递给节点的运行时上下文指定一个 `contextSchema`。这对于向节点传递不属于图状态的信息非常有用。例如，您可能希望传递模型名称或数据库连接等依赖项。
:::

:::python
```python
@dataclass
class ContextSchema:
    llm_provider: str = "openai"

graph = StateGraph(State, context_schema=ContextSchema)
```

然后，您可以使用 `invoke` 方法的 `context` 参数将此上下文传入图。

```python
graph.invoke(inputs, context={"llm_provider": "anthropic"})
```
:::

:::js
```typescript
import * as z from "zod";

const ContextSchema = z.object({
  llm: z.union([z.literal("openai"), z.literal("anthropic")]),
});

const graph = new StateGraph(State, ContextSchema);
```

然后，你可以通过 `context` 属性将此配置传入图中。

```typescript
const config = { context: { llm: "anthropic" } };

await graph.invoke(inputs, config);
```
:::

然后，你可以在节点或条件边内部访问和使用此上下文：

:::python
```python
from langgraph.runtime import Runtime

def node_a(state: State, runtime: Runtime[ContextSchema]):
    llm = get_llm(runtime.context.llm_provider)
    # ...
```
:::

:::js
```typescript
import { Runtime } from "@langchain/langgraph";
import * as z from "zod";

const nodeA = (
  state: z.infer<typeof State>,
  runtime: Runtime<z.infer<typeof ContextSchema>>,
) => {
  const llm = getLLM(runtime.context?.llm);
  // ...
};
```
:::

有关配置的完整解析，请参阅[本指南](/oss/langgraph/use-graph-api#add-runtime-configuration)。

:::js

```typescript
graph.addNode("myNode", (state, runtime) => {
  const llmType = runtime.context?.llm || "openai";
  const llm = getLLM(llmType);
  return { results: `Hello, ${state.input}!` };
});
```

:::

### 递归限制

:::python
递归限制设置了图在单次执行期间可以执行的[超级步骤](#graphs)的最大数量。一旦达到限制，LangGraph 将抛出 `GraphRecursionError`。从版本 1.0.6 开始，默认递归限制设置为 1000 步。递归限制可以在运行时为任何图设置，并通过配置字典传递给 `invoke`/`stream`。重要的是，`recursion_limit` 是一个独立的 `config` 键，不应像所有其他用户定义的配置一样放在 `configurable` 键内。请参见下面的示例：

```python
graph.invoke(inputs, config={"recursion_limit": 5}, context={"llm": "anthropic"})
```

阅读[此操作指南](/oss/langgraph/graph-api#impose-a-recursion-limit)以了解更多关于递归限制的工作原理。
:::

:::js
递归限制设置了图在单次执行期间可以执行的[超级步骤](#graphs)的最大数量。一旦达到限制，LangGraph 将抛出 `GraphRecursionError`。默认情况下，此值设置为 25 步。递归限制可以在运行时为任何图设置，并通过配置对象传递给 `invoke`/`stream`。重要的是，`recursionLimit` 是一个独立的 `config` 键，不应像所有其他用户定义的配置一样放在 `configurable` 键内。请参见下面的示例：

```typescript
await graph.invoke(inputs, {
  recursionLimit: 5,
  context: { llm: "anthropic" },
});
```

:::

### 访问和处理递归计数器

:::python
当前步骤计数器可以在任何节点内的 `config["metadata"]["langgraph_step"]` 中访问，允许在达到递归限制之前进行主动的递归处理。这使你能够在图逻辑中实现优雅降级策略。
:::

:::js
当前步骤计数器可以在任何节点内的 `config.metadata.langgraph_step` 中访问，允许在达到递归限制之前进行主动的递归处理。这使你能够在图逻辑中实现优雅降级策略。
:::

#### 工作原理

:::python

步骤计数器存储在 `config["metadata"]["langgraph_step"]` 中。递归限制检查遵循以下逻辑：`step > stop`，其中 `stop = step + recursion_limit + 1`。当超过限制时，LangGraph 会抛出 `GraphRecursionError`。

:::

:::js

步骤计数器存储在 `config.metadata.langgraph_step` 中。递归限制检查遵循以下逻辑：`step > stop`，其中 `stop = step + recursionLimit + 1`。当超过限制时，LangGraph 会抛出 `GraphRecursionError`。

:::

#### 访问当前步骤计数器

你可以在任何节点内访问当前步骤计数器以监控执行进度。

:::python

#### 主动递归处理

LangGraph 提供了一个 `RemainingSteps` 托管值，用于跟踪在达到递归限制之前还剩余多少步。这允许在你的图中实现优雅降级。

:::python

```python
from typing import Annotated, Literal
from langgraph.graph import StateGraph, START, END
from langgraph.managed import RemainingSteps

class State(TypedDict):
    messages: Annotated[list, lambda x, y: x + y]
    remaining_steps: RemainingSteps  # 托管值 - 跟踪直到限制的步数

def reasoning_node(state: State) -> dict:
    # RemainingSteps 由 LangGraph 自动填充
    remaining = state["remaining_steps"]

    # 检查是否步数即将耗尽
    if remaining <= 2:
        return {"messages": ["接近限制，正在收尾..."]}

    # 正常处理
    return {"messages": ["思考中..."]}

def route_decision(state: State) -> Literal["reasoning_node", "fallback_node"]:
    """基于剩余步数进行路由"""
    if state["remaining_steps"] <= 2:
        return "fallback_node"
    return "reasoning_node"

def fallback_node(state: State) -> dict:
    """处理递归限制即将达到的情况"""
    return {"messages": ["达到复杂度限制，提供尽力而为的答案"]}

# 构建图
builder = StateGraph(State)
builder.add_node("reasoning_node", reasoning_node)
builder.add_node("fallback_node", fallback_node)
builder.add_edge(START, "reasoning_node")
builder.add_conditional_edges("reasoning_node", route_decision)
builder.add_edge("fallback_node", END)

graph = builder.compile()

# RemainingSteps 适用于任何 recursion_limit
result = graph.invoke({"messages": []}, {"recursion_limit": 10})
```

:::

:::js

设计具有明确终止条件的图，并将 `GraphRecursionError` 作为安全网捕获：

```typescript
import { StateGraph, END, GraphRecursionError } from "@langchain/langgraph";

interface State {
  messages: string[];
}

async function reasoningNode(state: State): Promise<Partial<State>> {
  // 正常处理 - 设计具有明确终止条件的图
  return {
    messages: [...state.messages, "thinking..."]
  };
}

// 构建具有明确终止逻辑的图
const graph = new StateGraph<State>({ channels: {} })
  .addNode("reasoning", reasoningNode)
  .addConditionalEdges("reasoning", (state) => {
    // 在此处添加你的终止条件
    if (state.messages.length >= 5) {
      return END;
    }
    return "reasoning";
  });

const app = graph.compile();

// 将 GraphRecursionError 作为安全网捕获
try {
  const result = await app.invoke(
    { messages: [] },
    { recursionLimit: 10 }
  );
} catch (error) {
  if (error instanceof GraphRecursionError) {
    console.log("达到递归限制，进行优雅处理");
    // 处理错误 - 返回部分结果、通知用户等
  }
}
```

:::

#### 主动式与被动式方法

处理递归限制主要有两种方法：主动式（在图内监控）和被动式（在外部捕获错误）。

:::python

```python
from typing import Annotated, Literal, TypedDict
from langgraph.graph import StateGraph, START, END
from langgraph.managed import RemainingSteps
from langgraph.errors import GraphRecursionError

class State(TypedDict):
    messages: Annotated[list, lambda x, y: x + y]
    remaining_steps: RemainingSteps

# 主动方法（推荐）- 使用 RemainingSteps
def agent_with_monitoring(state: State) -> dict:
    """主动监控并在图内处理递归"""
    remaining = state["remaining_steps"]

    # 早期检测 - 路由到内部处理
    if remaining <= 2:
        return {
            "messages": ["接近限制，返回部分结果"]
        }

    # 正常处理
    return {"messages": [f"处理中...（剩余 {remaining} 步）"]}

def route_decision(state: State) -> Literal["agent", END]:
    if state["remaining_steps"] <= 2:
        return END
    return "agent"

# 构建图
builder = StateGraph(State)
builder.add_node("agent", agent_with_monitoring)
builder.add_edge(START, "agent")
builder.add_conditional_edges("agent", route_decision)
graph = builder.compile()

# 主动方法：图优雅地完成
result = graph.invoke({"messages": []}, {"recursion_limit": 10})

# 响应式方法（后备）- 在外部捕获错误
try:
    result = graph.invoke({"messages": []}, {"recursion_limit": 10})
except GraphRecursionError as e:
    # 在图执行失败后进行外部处理
    result = {"messages": ["后备方案：递归限制已超出"]}
```

:::

:::js

```typescript
import { StateGraph, END, GraphRecursionError } from "@langchain/langgraph";

interface State {
  messages: string[];
}

async function agent(state: State): Promise<Partial<State>> {
  return {
    messages: [...state.messages, "Processing..."]
  };
}

// 使用显式终止逻辑构建图
const builder = new StateGraph<State>({ channels: {} })
  .addNode("agent", agent)
  .addConditionalEdges("agent", (state) => {
    // 将终止条件设计到你的图中
    if (state.messages.length >= 5) {
      return END;
    }
    return "agent";
  });

const graph = builder.compile();

// 响应式方法 - 捕获 GraphRecursionError 作为安全网
try {
  const result = await graph.invoke(
    { messages: [] },
    { recursionLimit: 10 }
  );
} catch (error) {
  if (error instanceof GraphRecursionError) {
    // 在图执行失败后进行外部处理
    console.log("递归限制已超出，正在优雅处理");
  }
}
```

:::

:::python

这些方法之间的主要区别是：

| 方法 | 检测时机 | 处理位置 | 控制流 |
|----------|-----------|----------|--------------|
| 主动方法（使用 `RemainingSteps`） | 在达到限制之前 | 在图内通过条件路由 | 图继续执行至完成节点 |
| 响应式方法（捕获 `GraphRecursionError`） | 在超出限制之后 | 在图外的 try/catch 中 | 图执行终止 |

**主动方法的优势：**

- 在图内优雅降级
- 可以在检查点中保存中间状态
- 提供更好的用户体验（返回部分结果）
- 图正常完成（无异常）

**响应式方法的优势：**

- 实现更简单
- 无需修改图逻辑
- 集中式错误处理

:::

:::js

响应式方法在超出限制后捕获 `GraphRecursionError`。请在你的图中设计显式终止条件，以避免首先触及限制。

| 方法 | 检测时机 | 处理位置 | 控制流 |
|----------|-----------|----------|--------------|
| 响应式方法（捕获 `GraphRecursionError`） | 在超出限制之后 | 在图外的 try/catch 中 | 图执行终止 |

**响应式方法的优势：**

- 实现简单
- 无需修改图逻辑
- 集中式错误处理

:::

#### 其他可用的元数据

:::python

除了 `langgraph_step`，以下元数据在 `config["metadata"]` 中也可用：

```python
def inspect_metadata(state: dict, config: RunnableConfig) -> dict:
    metadata = config["metadata"]

```python
    print(f"Step: {metadata['langgraph_step']}")
    print(f"Node: {metadata['langgraph_node']}")
    print(f"Triggers: {metadata['langgraph_triggers']}")
    print(f"Path: {metadata['langgraph_path']}")
    print(f"Checkpoint NS: {metadata['langgraph_checkpoint_ns']}")

    return state
```

:::

:::js

除了 `langgraph_step`，以下元数据也可以在 `config.metadata` 中找到：

```typescript
async function inspectMetadata(
  state: any,
  config: RunnableConfig
): Promise<any> {
  const metadata = config.metadata;

  console.log(`Step: ${metadata?.langgraph_step}`);
  console.log(`Node: ${metadata?.langgraph_node}`);
  console.log(`Triggers: ${metadata?.langgraph_triggers}`);
  console.log(`Path: ${metadata?.langgraph_path}`);
  console.log(`Checkpoint NS: ${metadata?.langgraph_checkpoint_ns}`);

  return state;
}
```

:::

## 可视化

能够可视化图通常很有帮助，尤其是当它们变得更加复杂时。LangGraph 提供了几种内置的可视化图的方法。更多信息请参阅[此操作指南](/oss/langgraph/use-graph-api#visualize-your-graph)。
