---
title: 拆分 HTML
---
将 HTML 文档分割成易于管理的块对于各种文本处理任务（如自然语言处理、搜索索引等）至关重要。在本指南中，我们将探讨 LangChain 提供的三种不同的文本分割器，您可以使用它们来有效地分割 HTML 内容：

- [**HTMLHeaderTextSplitter**](#using-htmlheadertextsplitter)
- [**HTMLSectionSplitter**](#using-htmlsectionsplitter)
- [**HTMLSemanticPreservingSplitter**](#using-htmlsemanticpreservingsplitter)

这些分割器各有其独特的功能和用例。本指南将帮助您理解它们之间的区别、为何选择其中一个而非其他，以及如何有效地使用它们。

```
pip install -qU langchain-text-splitters
```

## 分割器概述

### [HTMLHeaderTextSplitter](#using-htmlheadertextsplitter)

<Info>
**当您希望根据标题保留文档的层次结构时非常有用。**
</Info>

**描述**：根据 HTML 标题标签（例如 `<h1>`、`<h2>`、`<h3>` 等）分割文本，并为与任何给定块相关的每个标题添加元数据。

**能力**：
- 在 HTML 元素级别分割文本。
- 保留文档结构中编码的上下文丰富信息。
- 可以逐个元素返回块，也可以将具有相同元数据的元素组合在一起。

___

### [HTMLSectionSplitter](#using-htmlsectionsplitter)

<Info>
当您希望将 HTML 文档分割成更大的部分（例如 `<section>`、`<div>` 或自定义部分）时非常有用。
</Info>

**描述**：类似于 HTMLHeaderTextSplitter，但侧重于根据指定的标签将 HTML 分割成部分。

**能力**：
- 使用 XSLT 转换来检测和分割部分。
- 内部使用 `RecursiveCharacterTextSplitter` 处理大块部分。
- 考虑字体大小来确定部分。

___

### [HTMLSemanticPreservingSplitter](#using-htmlsemanticpreservingsplitter)

<Info>
**当您需要确保结构化元素（如表格、列表）不被跨块分割，以保持上下文相关性时，这是理想的选择。**
</Info>

**描述**：将 HTML 内容分割成易于管理的块，同时保留重要元素（如表格、列表和其他 HTML 组件）的语义结构。

**能力**：
- 保留表格、列表和其他指定的 HTML 元素。
- 允许为特定的 HTML 标签定义自定义处理器。
- 确保文档的语义含义得以保持。
- 内置标准化和停用词移除功能。

___

### 选择合适的分割器

- **使用 `HTMLHeaderTextSplitter` 当**：您需要根据 HTML 文档的标题层次结构进行分割，并维护关于标题的元数据。
- **使用 `HTMLSectionSplitter` 当**：您需要将文档分割成更大、更通用的部分，可能基于自定义标签或字体大小。
- **使用 `HTMLSemanticPreservingSplitter` 当**：您需要将文档分割成块，同时保留表格和列表等语义元素，确保它们不被分割且其上下文得以保持。

| 特性 | HTMLHeaderTextSplitter | HTMLSectionSplitter | HTMLSemanticPreservingSplitter |
|--------------------------------------------|------------------------|---------------------|-------------------------------|
| 基于标题分割 | 是 | 是 | 是 |
| 保留语义元素（表格、列表） | 否 | 否 | 是 |
| 为标题添加元数据 | 是 | 是 | 是 |
| 为 HTML 标签提供自定义处理器 | 否 | 否 | 是 |
| 保留媒体（图像、视频） | 否 | 否 | 是 |
| 考虑字体大小 | 否 | 是 | 否 |
| 使用 XSLT 转换 | 否 | 是 | 否 |

## 示例 HTML 文档

让我们使用以下 HTML 文档作为示例：

```python
html_string = """
<!DOCTYPE html>
  <html lang='en'>
  <head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>Fancy Example HTML Page</title>
  </head>
  <body>
    <h1>Main Title</h1>
    <p>This is an introductory paragraph with some basic content.</p>

    <h2>Section 1: Introduction</h2>
    <p>This section introduces the topic. Below is a list:</p>
    <ul>
      <li>First item</li>
      <li>Second item</li>
      <li>Third item with <strong>bold text</strong> and <a href='#'>a link</a></li>
    </ul>

    <h3>Subsection 1.1: Details</h3>
    <p>This subsection provides additional details. Here's a table:</p>
    <table border='1'>
      <thead>
        <tr>
          <th>Header 1</th>
          <th>Header 2</th>
          <th>Header 3</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Row 1, Cell 1</td>
          <td>Row 1, Cell 2</td>
          <td>Row 1, Cell 3</td>
        </tr>
        <tr>
          <td>Row 2, Cell 1</td>
          <td>Row 2, Cell 2</td>
          <td>Row 2, Cell 3</td>
        </tr>
      </tbody>
    </table>

    <h2>Section 2: Media Content</h2>
    <p>This section contains an image and a video:</p>
      <img src='example_image_link.mp4' alt='Example Image'>
      <video controls width='250' src='example_video_link.mp4' type='video/mp4'>
      Your browser does not support the video tag.
    </video>

    <h2>Section 3: Code Example</h2>
    <p>This section contains a code block:</p>
    <pre><code data-lang="html">
    &lt;div&gt;
      &lt;p&gt;This is a paragraph inside a div.&lt;/p&gt;
    &lt;/div&gt;
    </code></pre>

    <h2>Conclusion</h2>
    <p>This is the conclusion of the document.</p>
  </body>
  </html>
"""
```

## 使用 HTMLHeaderTextSplitter

[HTMLHeaderTextSplitter](https://python.langchain.com/api_reference/text_splitters/html/langchain_text_splitters.html.HTMLHeaderTextSplitter.html) 是一个“结构感知”的[文本分割器](/oss/integrations/splitters)，它在 HTML 元素级别分割文本，并为与任何给定块“相关”的每个标题添加元数据。它可以逐个元素返回块，也可以将具有相同元数据的元素组合在一起，其目标是 (a) 将相关文本（或多或少）按语义分组，以及 (b) 保留文档结构中编码的上下文丰富信息。它可以与其他文本分割器一起用作分块管道的一部分。

它类似于用于 Markdown 文件的 [MarkdownHeaderTextSplitter](/oss/integrations/splitters/markdown_header_metadata_splitter)。

要指定在哪些标题上进行分割，请在实例化 `HTMLHeaderTextSplitter` 时指定 `headers_to_split_on`，如下所示。

```python
from langchain_text_splitters import HTMLHeaderTextSplitter

headers_to_split_on = [
    ("h1", "Header 1"),
    ("h2", "Header 2"),
    ("h3", "Header 3"),
]

html_splitter = HTMLHeaderTextSplitter(headers_to_split_on)
html_header_splits = html_splitter.split_text(html_string)
html_header_splits
```



```text
[Document(metadata={'Header 1': 'Main Title'}, page_content='This is an introductory paragraph with some basic content.'),
 Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Section 1: Introduction'}, page_content='This section introduces the topic. Below is a list:  \nFirst item Second item Third item with bold text and a link'),
 Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Section 1: Introduction', 'Header 3': 'Subsection 1.1: Details'}, page_content="This subsection provides additional details. Here's a table:"),
 Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Section 2: Media Content'}, page_content='This section contains an image and a video:'),
 Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Section 3: Code Example'}, page_content='This section contains a code block:'),
 Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Conclusion'}, page_content='This is the conclusion of the document.')]
```


要返回每个元素及其关联的标题，请在实例化 `HTMLHeaderTextSplitter` 时指定 `return_each_element=True`：

```python
html_splitter = HTMLHeaderTextSplitter(
    headers_to_split_on,
    return_each_element=True,
)
html_header_splits_elements = html_splitter.split_text(html_string)
```

与上面按标题聚合元素的情况进行比较：

```python
for element in html_header_splits[:2]:
    print(element)
```
```python
page_content='This is an introductory paragraph with some basic content.' metadata={'Header 1': 'Main Title'}
page_content='This section introduces the topic. Below is a list:
First item Second item Third item with bold text and a link' metadata={'Header 1': 'Main Title', 'Header 2': 'Section 1: Introduction'}
```
现在每个元素都作为一个独立的 `Document` 返回：

```python
for element in html_header_splits_elements[:3]:
    print(element)
```
```python
page_content='This is an introductory paragraph with some basic content.' metadata={'Header 1': 'Main Title'}
page_content='This section introduces the topic. Below is a list:' metadata={'Header 1': 'Main Title', 'Header 2': 'Section 1: Introduction'}
page_content='First item Second item Third item with bold text and a link' metadata={'Header 1': 'Main Title', 'Header 2': 'Section 1: Introduction'}
```
### 如何从 URL 或 HTML 文件分割：

要直接从 URL 读取，请将 URL 字符串传递给 `split_text_from_url` 方法。

类似地，可以将本地 HTML 文件传递给 `split_text_from_file` 方法。

```python
url = "https://plato.stanford.edu/entries/goedel/"

headers_to_split_on = [
    ("h1", "Header 1"),
    ("h2", "Header 2"),
    ("h3", "Header 3"),
    ("h4", "Header 4"),
]

html_splitter = HTMLHeaderTextSplitter(headers_to_split_on)

# 对于本地文件，使用 html_splitter.split_text_from_file(<path_to_file>)
html_header_splits = html_splitter.split_text_from_url(url)
```

### 如何限制块大小：

`HTMLHeaderTextSplitter` 基于 HTML 标题进行分割，可以与另一个基于字符长度限制分割的分割器（例如 `RecursiveCharacterTextSplitter`）组合使用。

这可以通过使用第二个分割器的 `.split_documents` 方法来实现：

```python
from langchain_text_splitters import RecursiveCharacterTextSplitter

chunk_size = 500
chunk_overlap = 30
text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=chunk_size, chunk_overlap=chunk_overlap
)

# 分割
splits = text_splitter.split_documents(html_header_splits)
splits[80:85]
```



```text
[Document(metadata={'Header 1': 'Kurt Gödel', 'Header 2': '2. Gödel’s Mathematical Work', 'Header 3': '2.2 The Incompleteness Theorems', 'Header 4': '2.2.1 The First Incompleteness Theorem'}, page_content='We see that Gödel first tried to reduce the consistency problem for analysis to that of arithmetic. This seemed to require a truth definition for arithmetic, which in turn led to paradoxes, such as the Liar paradox (“This sentence is false”) and Berry’s paradox (“The least number not defined by an expression consisting of just fourteen English words”). Gödel then noticed that such paradoxes would not necessarily arise if truth were replaced by provability. But this means that arithmetic truth'),
 Document(metadata={'Header 1': 'Kurt Gödel', 'Header 2': '2. Gödel’s Mathematical Work', 'Header 3': '2.2 The Incompleteness Theorems', 'Header 4': '2.2.1 The First Incompleteness Theorem'}, page_content='means that arithmetic truth and arithmetic provability are not co-extensive — whence the First Incompleteness Theorem.'),
 Document(metadata={'Header 1': 'Kurt Gödel', 'Header 2': '2. Gödel’s Mathematical Work', 'Header 3': '2.2 The Incompleteness Theorems', 'Header 4': '2.2.1 The First Incompleteness Theorem'}, page_content='This account of Gödel’s discovery was told to Hao Wang very much after the fact; but in Gödel’s contemporary correspondence with Bernays and Zermelo, essentially the same description of his path to the theorems is given. (See Gödel 2003a and Gödel 2003b respectively.) From those accounts we see that the undefinability of truth in arithmetic, a result credited to Tarski, was likely obtained in some form by Gödel by 1931. But he neither publicized nor published the result; the biases logicians'),
 Document(metadata={'Header 1': 'Kurt Gödel', 'Header 2': '2. Gödel’s Mathematical Work', 'Header 3': '2.2 The Incompleteness Theorems', 'Header 4': '2.2.1 The First Incompleteness Theorem'}, page_content='result; the biases logicians had expressed at the time concerning the notion of truth, biases which came vehemently to the fore when Tarski announced his results on the undefinability of truth in formal systems 1935, may have served as a deterrent to Gödel’s publication of that theorem.'),
 Document(metadata={'Header 1': 'Kurt Gödel', 'Header 2': '2. Gödel’s Mathematical Work', 'Header 3': '2.2 The Incompleteness Theorems', 'Header 4': '2.2.2 The proof of the First Incompleteness Theorem'}, page_content='We now describe the proof of the two theorems, formulating Gödel’s results in Peano arithmetic. Gödel himself used a system related to that defined in Principia Mathematica, but containing Peano arithmetic. In our presentation of the First and Second Incompleteness Theorems we refer to Peano arithmetic as P, following Gödel’s notation.')]
```


### 局限性

不同的 HTML 文档之间可能存在相当大的结构差异，虽然 `HTMLHeaderTextSplitter` 会尝试将任何给定块的所有“相关”标题附加到该块，但有时可能会遗漏某些标题。例如，该算法假设了一个信息层次结构，其中标题始终位于关联文本的“上方”节点，即前一个兄弟节点、祖先节点及其组合。在以下新闻文章中（截至撰写本文时），文档的结构使得顶级标题的文本虽然标记为“h1”，但与我们所期望的“上方”文本元素位于*不同的*子树中——因此我们可以观察到“h1”元素及其关联文本没有出现在块元数据中（但是，在适用的情况下，我们确实看到了“h2”及其关联文本）：

```python
url = "https://www.cnn.com/2023/09/25/weather/el-nino-winter-us-climate/index.html"

headers_to_split_on = [
    ("h1", "Header 1"),
    ("h2", "Header 2"),
]

html_splitter = HTMLHeaderTextSplitter(headers_to_split_on)
html_header_splits = html_splitter.split_text_from_url(url)
print(html_header_splits[1].page_content[:500])
```
```text
No two El Niño winters are the same, but many have temperature and precipitation trends in common.
Average conditions during an El Niño winter across the continental US.
One of the major reasons is the position of the jet stream, which often shifts south during an El Niño winter. This shift typically brings wetter and cooler weather to the South while the North becomes drier and warmer, according to NOAA.
Because the jet stream is essentially a river of air that storms flow through, they c
```
## 使用 HTMLSectionSplitter

在概念上类似于 [HTMLHeaderTextSplitter](#using-htmlheadertextsplitter)，`HTMLSectionSplitter` 是一个“结构感知”的[文本分割器](/oss/integrations/splitters)，它在元素级别分割文本，并为与任何给定块“相关”的每个标题添加元数据。它允许您按部分分割 HTML。

它可以逐个元素返回块，也可以将具有相同元数据的元素组合在一起，其目标是 (a) 将相关文本（或多或少）按语义分组，以及 (b) 保留文档结构中编码的上下文丰富信息。

使用 `xslt_path` 提供 XSLT 文件的绝对路径，以转换 HTML，使其能够根据提供的标签检测部分。默认使用 `data_connection/document_transformers` 目录中的 `converting_to_header.xslt` 文件。这是为了将 HTML 转换为更容易检测部分的格式/布局。例如，可以根据字体大小将 `span` 转换为标题标签，以便被检测为一个部分。

### 如何分割 HTML 字符串：

```python
from langchain_text_splitters import HTMLSectionSplitter

headers_to_split_on = [
    ("h1", "Header 1"),
    ("h2", "Header 2"),
]

html_splitter = HTMLSectionSplitter(headers_to_split_on)
html_header_splits = html_splitter.split_text(html_string)
html_header_splits
```



```text
[Document(metadata={'Header 1': 'Main Title'}, page_content='Main Title \n This is an introductory paragraph with some basic content.'),
 Document(metadata={'Header 2': 'Section 1: Introduction'}, page_content="Section 1: Introduction \n This section introduces the topic. Below is a list: \n \n First item \n Second item \n Third
