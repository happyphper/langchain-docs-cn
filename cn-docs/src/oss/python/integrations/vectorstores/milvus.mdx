---
title: Milvus
---
>[Milvus](https://milvus.io/docs/overview.md) 是一个用于存储、索引和管理由深度神经网络及其他机器学习（ML）模型生成的海量嵌入向量的数据库。

本笔记本展示了如何使用与 Milvus 向量数据库相关的功能。

## 安装设置

你需要通过 `pip install -qU langchain-milvus` 安装 `langchain-milvus` 来使用此集成。

```python
pip install -qU langchain-milvus
```

### 凭证

使用 `Milvus` 向量存储无需凭证。

## 初始化

<EmbeddingTabs/>

```python
# | output: false
# | echo: false
from langchain_openai import OpenAIEmbeddings

embeddings = OpenAIEmbeddings(model="text-embedding-3-large")
```

### Milvus Lite

最便捷的原型设计方式是使用 Milvus Lite，所有数据都存储在本地向量数据库文件中。仅支持使用 Flat 索引。

```python
from langchain_milvus import Milvus

URI = "./milvus_example.db"

vector_store = Milvus(
    embedding_function=embeddings,
    connection_args={"uri": URI},
    index_params={"index_type": "FLAT", "metric_type": "L2"},
)
```

### Milvus 服务器

如果你有大量数据（例如超过一百万条向量），我们建议在 [Docker](https://milvus.io/docs/install_standalone-docker.md#Start-Milvus) 或 [Kubernetes](https://milvus.io/docs/install_cluster-milvusoperator.md) 上设置一个性能更强的 Milvus 服务器。

Milvus 服务器支持多种[索引](https://milvus.io/docs/index.md?tab=floating)。利用这些不同的索引可以显著增强检索能力并加快检索过程，以满足你的特定需求。

以 Milvus 单机版为例。要启动 Docker 容器，可以运行以下命令：

```python
!curl -sfL https://raw.githubusercontent.com/milvus-io/milvus/master/scripts/standalone_embed.sh -o standalone_embed.sh

!bash standalone_embed.sh start
```

```text
Password:
```

这里我们创建一个 Milvus 数据库：

```python
from pymilvus import Collection, MilvusException, connections, db, utility

conn = connections.connect(host="127.0.0.1", port=19530)

# 检查数据库是否存在
db_name = "milvus_demo"
try:
    existing_databases = db.list_database()
    if db_name in existing_databases:
        print(f"Database '{db_name}' already exists.")

        # 使用数据库上下文
        db.using_database(db_name)

        # 删除数据库中的所有集合
        collections = utility.list_collections()
        for collection_name in collections:
            collection = Collection(name=collection_name)
            collection.drop()
            print(f"Collection '{collection_name}' has been dropped.")

        db.drop_database(db_name)
        print(f"Database '{db_name}' has been deleted.")
    else:
        print(f"Database '{db_name}' does not exist.")
        database = db.create_database(db_name)
        print(f"Database '{db_name}' created successfully.")
except MilvusException as e:
    print(f"An error occurred: {e}")
```

```text
Database 'milvus_demo' does not exist.
Database 'milvus_demo' created successfully.
```

注意下面 URI 的变化。实例初始化后，请访问 [127.0.0.1:9091/webui](http://127.0.0.1:9091/webui) 查看本地 Web UI。

以下是如何使用 Milvus 数据库服务创建向量存储实例的示例：

```python
from langchain_milvus import BM25BuiltInFunction, Milvus

URI = "http://localhost:19530"

vectorstore = Milvus(
    embedding_function=embeddings,
    connection_args={"uri": URI, "token": "root:Milvus", "db_name": "milvus_demo"},
    index_params={"index_type": "FLAT", "metric_type": "L2"},
    consistency_level="Strong",
    drop_old=False,  # 如果希望删除已存在的同名集合，请设置为 True
)
```

> 如果你想使用 Zilliz Cloud（Milvus 的全托管云服务），请调整 uri 和 token，它们分别对应 Zilliz Cloud 中的 [公共端点](https://docs.zilliz.com/docs/byoc/quick-start#free-cluster-details) 和 [API 密钥](https://docs.zilliz.com/docs/byoc/quick-start#free-cluster-details)。

### 使用 Milvus 集合分隔数据

你可以在同一个 Milvus 实例的不同集合中存储不相关的文档。

以下是创建新集合的方法：

```python
from langchain_core.documents import Document

vector_store_saved = Milvus.from_documents(
    [Document(page_content="foo!")],
    embeddings,
    collection_name="langchain_example",
    connection_args={"uri": URI},
)
```

以下是检索该存储集合的方法：

```python
vector_store_loaded = Milvus(
    embeddings,
    connection_args={"uri": URI},
    collection_name="langchain_example",
)
```

## 管理向量存储

创建向量存储后，我们可以通过添加和删除不同项目来与之交互。

### 向向量存储添加项目

我们可以使用 `add_documents` 函数向向量存储添加项目。

```python
from uuid import uuid4

from langchain_core.documents import Document

document_1 = Document(
    page_content="I had chocolate chip pancakes and scrambled eggs for breakfast this morning.",
    metadata={"source": "tweet"},
)

document_2 = Document(
    page_content="The weather forecast for tomorrow is cloudy and overcast, with a high of 62 degrees.",
    metadata={"source": "news"},
)

document_3 = Document(
    page_content="Building an exciting new project with LangChain - come check it out!",
    metadata={"source": "tweet"},
)

document_4 = Document(
    page_content="Robbers broke into the city bank and stole $1 million in cash.",
    metadata={"source": "news"},
)

document_5 = Document(
    page_content="Wow! That was an amazing movie. I can't wait to see it again.",
    metadata={"source": "tweet"},
)

document_6 = Document(
    page_content="Is the new iPhone worth the price? Read this review to find out.",
    metadata={"source": "website"},
)

document_7 = Document(
    page_content="The top 10 soccer players in the world right now.",
    metadata={"source": "website"},
)

document_8 = Document(
    page_content="LangGraph is the best framework for building stateful, agentic applications!",
    metadata={"source": "tweet"},
)

document_9 = Document(
    page_content="The stock market is down 500 points today due to fears of a recession.",
    metadata={"source": "news"},
)

document_10 = Document(
    page_content="I have a bad feeling I am going to get deleted :(",
    metadata={"source": "tweet"},
)

documents = [
    document_1,
    document_2,
    document_3,
    document_4,
    document_5,
    document_6,
    document_7,
    document_8,
    document_9,
    document_10,
]
uuids = [str(uuid4()) for _ in range(len(documents))]

vector_store.add_documents(documents=documents, ids=uuids)
```

### 从向量存储中删除项目

```python
vector_store.delete(ids=[uuids[-1]])
```

```text
(insert count: 0, delete count: 1, upsert count: 0, timestamp: 0, success count: 0, err count: 0, cost: 0)
```

## 查询向量存储

创建向量存储并添加相关文档后，你很可能会希望在运行链或代理时查询它。

### 直接查询

#### 相似性搜索

可以通过以下方式执行简单的相似性搜索，并对元数据进行过滤：

```python
results = vector_store.similarity_search(
    "LangChain provides abstractions to make working with LLMs easy",
    k=2,
    expr='source == "tweet"',
)
for res in results:
    print(f"* {res.page_content} [{res.metadata}]")
```

```text
* Building an exciting new project with LangChain - come check it out! [{'pk': '9905001c-a4a3-455e-ab94-72d0ed11b476', 'source': 'tweet'}]
* LangGraph is the best framework for building stateful, agentic applications! [{'pk': '1206d237-ee3a-484f-baf2-b5ac38eeb314', 'source': 'tweet'}]
```

#### 带分数的相似性搜索

你也可以进行带分数的搜索：

```python
results = vector_store.similarity_search_with_score(
    "Will it be hot tomorrow?", k=1, expr='source == "news"'
)
for res, score in results:
    print(f"* [SIM={score:3f}] {res.page_content} [{res.metadata}]")
```

```text
* [SIM=21192.628906] bar [{'pk': '2', 'source': 'https://example.com'}]
```

要查看使用 `Milvus` 向量存储时可用的所有搜索选项的完整列表，请访问 [API 参考](https://python.langchain.com/api_reference/milvus/vectorstores/langchain_milvus.vectorstores.milvus.Milvus.html)。

### 转换为检索器进行查询

你也可以将向量存储转换为检索器，以便在链中更轻松地使用。

```python
retriever = vector_store.as_retriever(search_type="mmr", search_kwargs={"k": 1})
retriever.invoke("Stealing from the bank is a crime", filter={"source": "news"})
```

```text
[Document(metadata={'pk': 'eacc7256-d7fa-4036-b1f7-83d7a4bee0c5', 'source': 'news'}, page_content='Robbers broke into the city bank and stole $1 million in cash.')]
```

## 混合搜索

最常见的混合搜索场景是稠密 + 稀疏混合搜索，其中候选结果同时使用语义向量相似性和精确关键词匹配进行检索。这些方法的结果被合并、重新排序，然后传递给 LLM 以生成最终答案。这种方法平衡了精确性和语义理解，使其对于多样化的查询场景非常有效。

### 全文搜索

自 [Milvus 2.5](https://milvus.io/blog/introduce-milvus-2-5-full-text-search-powerful-metadata-filtering-and-more.md) 起，通过 Sparse-BM25 方法原生支持全文搜索，该方法将 BM25 算法表示为稀疏向量。Milvus 接受原始文本作为输入，并自动将其转换为存储在指定字段中的稀疏向量，无需手动生成稀疏嵌入。

对于全文搜索，Milvus VectorStore 接受一个 `builtin_function` 参数。通过此参数，你可以传入一个 `BM25BuiltInFunction` 的实例。这与通常将稠密嵌入传递给 `VectorStore` 的语义搜索不同。

以下是 Milvus 中混合搜索的一个简单示例，使用 OpenAI 稠密嵌入进行语义搜索，使用 BM25 进行全文搜索：

```python
from langchain_milvus import BM25BuiltInFunction, Milvus
from langchain_openai import OpenAIEmbeddings

vectorstore = Milvus.from_documents(
    documents=documents,
    embedding=OpenAIEmbeddings(),
    builtin_function=BM25BuiltInFunction(),
    # `dense` 用于 OpenAI 嵌入，`sparse` 是 BM25 函数的输出字段
    vector_field=["dense", "sparse"],
    connection_args={
        "uri": URI,
    },
    consistency_level="Strong",
    drop_old=True,
)
```

> - 当你使用 `BM25BuiltInFunction` 时，请注意全文搜索在 Milvus 单机版和分布式版中可用，但在 Milvus Lite 中不可用（尽管已列入未来计划）。它也即将在 Zilliz Cloud（全托管 Milvus）中可用。更多信息请联系 [support@zilliz.com](mailto:support@zilliz.com)。

在上面的代码中，我们定义了一个 `BM25BuiltInFunction` 的实例并将其传递给 `Milvus` 对象。`BM25BuiltInFunction` 是 Milvus 中 [`Function`](https://milvus.io/docs/manage-collections.md#Function) 的一个轻量级包装类。我们可以将其与 `OpenAIEmbeddings` 一起使用，来初始化一个稠密 + 稀疏混合搜索的 Milvus 向量存储实例。

`BM25BuiltInFunction` 不要求客户端传递语料库或进行训练，所有处理都在 Milvus 服务器端自动完成，因此用户无需关心任何词汇表和语料库。此外，用户还可以自定义[分析器](https://milvus.io/docs/analyzer-overview.md#Analyzer-Overview)来实现 BM25 中的自定义文本处理。

### 对候选结果重新排序

在第一阶段检索之后，我们需要对候选结果进行重新排序以获得更好的结果。你可以参考[重新排序](https://milvus.io/docs/reranking.md#Reranking)获取更多信息。

以下是一个加权重新排序的示例：

```python
query = "What are the novels Lila has written and what are their contents?"

vectorstore.similarity_search(
    query, k=1, ranker_type="weighted", ranker_params={"weights": [0.6, 0.4]}
)
```

## 用于检索增强生成

有关如何使用此向量存储进行检索增强生成（RAG）的指南，请参阅以下部分：

- [教程](/oss/langchain/rag)
- [操作指南：使用 RAG 进行问答](https://python.langchain.com/docs/how_to/#qa-with-rag)
- [检索概念文档](https://python.langchain.com/docs/concepts/retrieval)

### 按用户检索

在构建检索应用时，通常需要考虑多个用户。这意味着你可能不仅为一个用户存储数据，还为许多不同的用户存储数据，并且他们不应该看到彼此的数据。

Milvus 建议使用 [partition_key](https://milvus.io/docs/multi_tenancy.md#Partition-key-based-multi-tenancy) 来实现多租户。以下是一个示例：
> 分区键功能在 Milvus Lite 中不可用，如果你想使用它，需要如上所述启动 Milvus 服务器。

```python
from langchain_core.documents import Document

docs = [
    Document(page_content="i worked at kensho", metadata={"namespace": "harrison"}),
    Document(page_content="i worked at facebook", metadata={"namespace": "ankush"}),
]
vectorstore = Milvus.from_documents(
    docs,
    embeddings,
    connection_args={"uri": URI},
    drop_old=True,
    partition_key_field="namespace",  # 使用 "namespace" 字段作为分区键
)
```

要使用分区键进行搜索，你应在搜索请求的布尔表达式中包含以下任一条件：

`search_kwargs={"expr": '<partition_key> == "xxxx"'}`

`search_kwargs={"expr": '<partition_key> == in ["xxx", "xxx"]'}`

请务必将 `<partition_key>` 替换为指定为分区键的字段名称。

Milvus 根据指定的分区键切换到相应的分区，根据分区键过滤实体，并在过滤后的实体中进行搜索。

```python
# 这将只获取 Ankush 的文档
vectorstore.as_retriever(search_kwargs={"expr": 'namespace == "ankush"'}).invoke(
    "where did i work?"
)
```

```python
[Document(page_content='i worked at facebook', metadata={'namespace': 'ankush'})]
```

```python
# 这将只获取 Harrison 的文档
vectorstore.as_retriever(search_kwargs={"expr": 'namespace == "harrison"'}).invoke(
    "where did i work?"
)
```

```python
[Document(page_content='i worked at kensho', metadata={'namespace': 'harrison'})]
```

---

## API 参考

有关 __ModuleName__VectorStore 所有功能和配置的详细文档，请参阅 API 参考：[python.langchain.com/api_reference/milvus/vectorstores/langchain_milvus.vectorstores.milvus.Milvus.html](https://python.langchain.com/api_reference/milvus/vectorstores/langchain_milvus.vectorstores.milvus.Milvus.html)
